Хорошие статьи:
https://habr.com/ru/articles/174467/
https://habr.com/ru/companies/skillbox/articles/442260/
https://habr.com/ru/companies/yandex_praktikum/articles/768492/
https://habr.com/ru/companies/yandex_praktikum/articles/728302/
https://selectel.ru/blog/tutorials/git-fetch-command-how-is-it-different-from-git-pull/
https://habr.com/ru/articles/150001/
https://old.calculate-linux.org/main/ru/git




 = = = Начало работы с Git, с репозиторием = = =

Для начала работы с Git нужно создать репозиторий. Это можно сделать двумя способами:
 1) превратить какую-либо директорию на компьютере в репозиторий
 2) склонировать удалённый репозиторий на свой копмьютер

	Чем папка (директория) отличается от репозитория? 
	Репозиторий -- это папка, которая отслеживается Git'ом. Признаком этого является
	  наличие в ней подпапки .git
	Всякий репозиторий является директорией, но не всякая директория -- репозиторий.

Способ первый.
  Мы должны текущим рабочим каталогом командной строки сделать папку с проектом. 
  ВНИМАНИЕ! Саму папку, а не каталог, её содержащий (что относится скорее ко второму способу)
  Затем надо ввести команду git init
  Она превратит текущую папку в репозиторий Git'а, создав при этом подпапку .git
  Всё, можно работать с гитом прям из этой директории 
    (т.е. не надо делать cd, в отличие от второго способа)

Способ второй.
  Мы должны текущим рабочим каталогом командной строки сделать папку, которая будет 
    содержать будущий репозиторий
  ВНИМАНИЕ! В отличие от первого способа, здесь мы как бы отправляемся уровнем выше,
    в наддиректорию. Ну хотя бы по той причине, что пока ещё нет директории репозитория.
    Самостоятельно создавать новую директорию тоже не надо, она будет создана автоматически.
    Просто надо быть на уровень выше.
  Далее пишем следующую команду:
    git clone <url>
	где <url> -- это адрес удалённого репозитория. В ГитХабе его можно найти следующим образом:
	зайти на страничку репозитория и вверху справа найти зелёную кнопку с надписью "<> Code". 
	Там на вкладке Local на подвкладке HTPPS будет текстовое поле с адресом, который нужно 
 	скопировать (есть даже специальная кнопка) -- это и будет нужным нам url'ом. 		
  Команда git clone создаст новую директорию с именем удалённого репозитория и скопирует в неё всё
    его содержимое (вместе с папкой .git, разумеется)
  Далее нужно будет перевести текущий рабочий каталог командной строки в эту директорию (с помощью
    комнады cd, например)
  Всё, можно работать.
  ПРИМЕЧАНИЕ.
    По умолчанию в процессе клонирования удалённому репозиторию присваивается имя origin
    Однако при клонировании можно задать другое имя, для этого следует использовать:
    git clone -o <newname> <url>

Лёша учил меня второму способу.
Говорил, что в первом способе ещё придётся потом настраивать origin (=удалённый репозиторий),
  что пока что я плохо представляю, как делать
  (хотя на данный момент у меня до сих пор возникают проблемы с этим origin и после второго 
  способа... м-да)


Как "разгититься"? Удалить папку ".git"

Как понять, в репозитории мы находимся или в папке?
Самый простой способ это сделать — набрать в терминале команду «git status». Если в ответ вы увидите 
ошибку «fatal: not a git repository (or any of the parent directories): .git», значит, в терминале
вы вызываете команду не из репозитория, а из обычной папки. Если вы увидели что-то другое, 
то вы находитесь в репозитории или внутри одной из папок, которая находится в нём (в частности, если
вы вызовите git status из папки .git, то получите следующее сообщение: «fatal: this operation must 
be run in a work tree»; вызов же из "нормальных" папок будет более привычным и адекватным).


Хорошая статья по этой теме: https://habr.com/ru/articles/718830/




 = = = Индексация (моими словами: прекоммит) = = =

index (=staging area = cache) — область зафиксированных изменений, т.е. всё то, 
	что вы подготовили к сохранению в репозиторий.

git add <file>...	Заиндексировать файл(ы)
git add	.		Заиндексировать всю текущую папку
git add -A		Заиндексировать все изменения
git add --all		То же, что -A
	
	Замечание насчёт "git add .":
	Если текущая папка -- корневая папка репозитория, то "git add ." == "git add -A"
	Но если в репозитории есть поддиректории и если перейти в одну из них, 
		то вызов "git add ." заиндексирует только её содержимое
	
	Замечание насчёт удаляемых файлов:
	Если мы удалили файлы из репозитория, то чтобы Гит тоже считал их удалёнными, нужно
	  закоммитить их удаление, а прежде -- заиндексировать! Иначе Гит не запишет удаление 
	  в свою историю и будет в git status отображать такие файлы в списке Changes not 
	  staged for commit красным цветом с пометой deleted.
	Удалившиеся файлы можно индексировать как с помощью "git add <file>", так и 
	  с помощью "git add .". Также они автоматически будут добавляться в коммит при 
	  выполнении команды git commit -a
	При этом с точки зрения операционной системы такие файлы уже, естественно,
	  не существуют, поэтому ввести их имена в командной строке с помощью Tab-подсказки 
	  не выйдет, однако ручной корректный ввод несуществующего файла будет корректно 
	  обработан, т.к. Git-то его помнит!
			
git restore --staged <file>...	Разыиндексировать файл(ы)

Добавление в индекс файла, в котором нет изменений, ни к чему не приведёт

  = = = Индексация файла по частям: git add -p = = =

  git add -p или git add --patch
  Открывает интерактивный интерфейс. 
  Проходит по диффу файла между текущей и последней закоммиченной/заиндексированной
    версией, отделяет друг от друга куски, между которыми как минимум 7 неизменных
    строк, спрашивает по каждому куску:
	y - индексировать этот кусок
	n - не индексировать этот кусок
	q - выйти (в индексе останется всё, что успели внести в индекс)
	a - индексировать этот кусок и все последующие куски в файле
	d - не индексировать этот кусок и все последующие куски в файле
	e - внести изменения в текущем куске вручную (открывается vim)
	? - вывести справку
	s - разделить этот кусок ещё сильнее:  не через 7 неизменных строк, а через 1

  Хорошая статья по теме: https://nuancesprog.ru/p/7502/




 = = = Статусы файлов в Гите = = =

untracked	Файл не отслеживается Гитом: ни разу не индексировался (свежедобавленный)
tracked		Файл отслеживается Гитом (тут и закоммиченные, и только проиндексированные)
staged		Файл заиндексирован
modified	Файл отличается от последней закоммиченной версии


	 = = Списки в гитстатусе = = 
	
	Untracked files
		список неотслеживаемых (untracked) файлов, помечается красным
	Changes not staged for commit
		список файлов с непроиндексированными изменениями (modified),
		    помечается словом modified и красным - если файл был изменён
		    помечается словом deleted и красным - если файл был удалён
	Changes to be committed
		список индексированных (staged, modified) файлов, 
		    помечается словом modified и зелёным - если индексировался ранее - ИЛИ
		    помечается словами new file и зелёным - если новый файл
		    помечается словом deleted и красным - если файл был удалён


	Если файл в проекте изменить, то он будет в Changes not staged for commit
	Если его заиндексировать, то он будет в Changes to be committed
	Если его снова изменить, то он будет и там, и там
		(при этом коммит на текущем этапе закоммитит только проиндексированную
		    версию, а git restore откатит тоже к индексированной версии,
		    и в этих обоих случаях из списка Changes to be committed файл пропадёт)
	
	Если все те три списка пусты, то гитстатус выводит вот это:
		On branch krull_fixes
		[Your branch is up to date with 'origin/<...>'.]
		nothing to commit, working tree clean




 = = = Отмена действий = = =

git restore <file>...		Отменить все неиндексированные изменения в файле(-ах)
git restore -W <file>		То же самое
git restore .			Отменить все неиндексированные изменения во всех отслеживаемых файлах 
							в текущей папке	(см. также git reset)
git restore --staged <file>...	Разыиндексировать файл(ы)
git restore -S <file>...	То же самое
git restore -S .		Разыиндексировать все файлы из текущей директории

Обрати внимание: git restore не меняет индекс, но меняет сам файл в репозитории, а git restore -S наоборот
меняет индекс, но сам файл в репозитории остаётся неизменным.

Если мы что-то поменяли в репозитории, наиндексировали, ещё раз поменяли и т.д., а потом решили откатить
репозиторий к последнему коммиту, то по идее надо сначала всё сперва разыиндексировать, потом 
все неиндексированные (т.е. ещё незаиндексированные и уже разындексированные) изменения отменить.
Логика подсказывает использовать "git restore -S .", затем "git restore .". Их можно объединить:

git restore -SW .		Отментить вообще все изменения в текушей папке, откатить до последнего коммита
						(эта команда не тронет лишь свежедобавленные и потому неотслеживаемые файлы)
					(да, ради этого я выше описал команду git restore -W)
Однако никто так не делает, ибо для этого есть git reset --hard: см. далее


git reset [--soft | --mixed | --hard] [<commit>]	Откат состояния к данному коммиту

git reset может содержать указатель на коммит (в таком случае мы перейдём к тому коммиту),
	а может и не содержать (тогда перейдём к текущему коммиту)
git reset тащит за собой указатель на текущую ветку (!!!)

git reset бывает трёх видов:
  1) --soft:
	Откатывает до коммита, а все изменения между новым и старым коммитами пишет в индекс (т.е. в staged)
	С самим репозиторием ничего не происходит, с изначальным индексом тоже ничего не происходит (разве что
	к нему возможно прибывает пополнение), изначальный список unstaged-изменений тоже остаются как был
  2) --mixed (делается по умолчанию, если не указывается флаг): 
	Откатывает до коммита, а все изменения между новым и старым коммитами пишет в unstaged,
	а всё, что изначально было в индексе, разындексирует -- т.е. тоже в unstaged
	Изначальные unstaged-измнения остаются как были (разве что к ним возможно прибывает пополнение)
	С репозиторием по-прежнему ничего не происходит
  3) --hard:
	Откатывает до коммита, а все изменения нафиг стирает, соответсвенно репозиторий откатывается 
	к состоянию на момент того коммита (за исключением лишь недавно добавленных в репозиторий 
	неотслеживаемых (untracked) файлов, их хардресет не замечает и потому не трогает; наличие таковых --
	единственное, что отличает состояние репозитория после хардресета от состояния того коммита, на
	который делается хардресет).
	Весь изначальный индекс и все изначальные незакоммиченные изменения нафиг уничтожаются БЕЗВОЗВРАТНО!
		(помимо уже упомянутых untracked-файлов)
	ВНИМАНИЕ! Перед выполнием всегда проверять с помощью git status, есть ли изменения (заиндексированные 
	или нет), потому что в результате действия хардресета они пропадут БЕЗВОЗВРАТНО! ну если конечно они
	нам нужны :) А если снести эти изменения наша цель, то таки да, хардресет наше всё :))
	ВНИМАНИЕ! Если делать хардресет на коммит, отличный от текущего, то с текущего коммита уйдёт текущая 
	ветка. Если на этот коммит указывала только эта ветка и не указывали никакие другие ветки даже 
	опосредованно через иные коммиты, то в результае выполнения git reset --hard этот бывший текущий коммит
	становится висящим (т.е. на него не указывает ни одна ветка), вместе с ним висящими становятся и все 
	его предки вплоть невключительно до того коммита, на который хоть какая-то ветвь всё же указывает --
	в результате все эти коммиты пропадут из git log, добраться до них можно будет только через git reflog

Замечения:
  git reset --soft без указания на коммит (или, что тоже самое, с указанием на текущий коммит) не делает ничего
  git reset без указания на коммит аналогичен действию git restore -S . (если мы в корневой папке репозитория),
	т.е. тупо очищает индекс
  git reset --hard без указания на коммит обнуляет все измненения (заиндексированные и нет) в репозитории,
	т.е. действует как git restore -SW . (опять-таки, если мы в корневой папке репозитория); исключение
	составляют лишь свежедобавленные и потому неотслеживаемые файлы
  git reset --hard <commit> похож по действию на git checkout <commit>, вот только первый тащит за собой 
	текущую ветку, а второй оставляет её там, где была. Но с репозиторием происходит одно и то же.
	ВНИМАНИЕ! У обоих способов есть проблемки: у чекаута -- оторванная башка, опасная тем, что может 
	впоследствии породить висящие пропащие коммиты, хардресет же может сразу один или несколько коммитов 
	сделать висящими. Подробнее об этом -- в справке по каждой команде.
  git reset --hard HEAD~ удаляет последний коммит.

Хорошая небольшая статья про git reset: https://habr.com/ru/articles/203282/




 = = = Коммитинг = = =

git commit			Закоммитить текущий индекс (откроется сторонний текстовый редактор 
					для написания комментария)
git commit -m <comment>		Закоммитить текущий индекс (комментарий указывается прям здесь в кавычках,
					а если он одним словом без пробелов, то можно и без кавычек)
git commit -a			Закоммитить все изменения в проекте 
					(кроме добавления новых файлов, т.к. они untracked;
					при этом удаления новых файлов будут закоммичены, т.к. они tracked)
git commit -am <comment>	Комбо из предыдущих двух; довольно ходовая команда :)

  Замечание:
  Если индекс пуст, то команды <git commit>, <git commit -m "smthng"> работают так же, как <git status>.
  Команда <git commit -a> в случае пустого индекса, но непустого списка изменений работает как полагается 
    (всё индексирует + всё коммитит), но в случае пустого списка изменений всё-таки работает как <git status> 
    (ну то есть выдаёт слова "On branch <ветка> // nothing to commit, working tree clean") 

git commit --amend		Исправить последний коммит
					(работает только для последнего, остальные уже не исправить)
				Также можно добавить флаги -a, -m  или -am (см. выше)
	ВНИМАНИЕ! Если исправлять уже запушенный коммит, то потом пуш просто так не получится, 
	  но можно сделать форспуш (подробнее см. Пушинг)
git commit --amend --no-edit	Исправить последний коммит, но не трогать при этом коммент

git checkout <commit>		Перевод состояния репозитория (т.е. указателя HEAD) к данному коммиту 
					(указывается его хэш или любой иной указатель на этот коммит, если есть)
					Работает, если репозиторий не менялся с момента последнего коммитинга
	ВНИМАНИЕ!
	По уму HEAD должен указывать на какую-то ветку (потому пишется обычно "HEAD -> main", а не "HEAD, main"),
	здесь же получается, что HEAD указывает напрямую на коммит. Такая ситуация называется detached HEAD 
	(отсоединённый или оторванный HEAD), команда git status выдаёт "HEAD detached at <commit hash>",
	причём красным цветом. По-хорошему репозиторий не должен долго находиться в таком состоянии. Тут вижу
	два варианта действий:
	  1) Если мы просто зашли посмотреть на коммит: посмотрели и возвращаемся обратно на ту ветку, где были
	  2) Если мы захотели отпочковаться от данного коммита: первым делом следует создать здесь 
		новую ветку, затем не забыть(!) на неё переключиться (или одним выстрелом двух зайцев с помощью
		git checkout -b) -- тем самым мы выйдем из состояния оторванной башки; 
		далее можно коммитить в эту ветку сколько угодно
	Хорошая статья по теме: https://webhamster.ru/mytetrashare/index/mtb0/1465119902140pozfhh1
	(в т.ч. см. там причину, почему оторванный HEAD -- зло)

git revert <commit hash>	Отмена изменений коммита -- не такая простая штука, как кажется на перввый взгляд
					см. чуть ниже!!!
				При этом создаётся новый коммит, который добавляется в конец дерева коммитов
					(т.е. после текущего HEAD, ну и HEAD туда перемещается, всё норм тут)
				И открывается сторонний редактор для редактирования коммента, там по умолчанию:
					Revert "<коммент того коммита>"
				Кстати, если сделать реверт на реверт, то коммент будет: 
					Reapply "<коммент того коммита>"
	КАК В ДЕЙСТВИТЕЛЬНОСТИ РАБОТАЕТ git revert:
	  Каждый коммит в некотором смысле является набором изменений по сравнению в предыдущей версией.
	  И git revert инвертирует именно сами изменения между соседними коммитами, а не откаывает к какой-то
	  старой версии. Именно что запросто может создасться версия репозитория, которой ещё не было!
	  Конечно, если мы ревёртим последний коммит, то у нас создаётся новый коммит с таким же состоянием 
	  репозитория, как у предпоследнего коммита (точнее уже предпредпоследнего). Но если мы ревёртим
	  не последний коммит, то инвертирование какого-нибудь позапозапрошлого набора изменений, вообще говоря,
	  запросто может привести к конфликту изменений. Этот конфликт изменений может быть разрешён
	  в автоматическом режиме, а может и нет -- придётся использовать git mergetool (см. Мёржинг)
git revert --abort		Отменяет выполнение revert и возвращает к состоянию до её вызова
				(например, если возник конфликт слияния и хочется просто всё вернуть как было)
git cherry-pick <commit_hash>	берёт изменения, которые были сделаны в указанном коммите, 
	и накладывает на текущую ветку. Можно сказать это как git revert, только наоборот
	(наверное есть некоторые отличия, но пока не хочу в них вдаваться)
git cherry-pick --abort		Отменяет выполнение cherry-pick и возвращает к состоянию до её вызова
				(например, если возник конфликт слияния и хочется просто всё вернуть как было)

Как удалить последний коммит? 
git reset --hard HEAD~
(Разумеется, перед хардресетом надо проверить, нет ли незакоммиченных изменений, которые не хочется терять)




 = = = Работа с ветками = = =

Всякие названия: 
	origin		Имя удалённого репозитория, с которого сделал clone.
			Это имя "origin" даётся автоматически по умолчанию, однако вместо него
			можно задать другое имя, если вместо git clone <url> написать 
			git clone -o <newname> <url> при изначальном клонировании репозитория.
	main		Главная ветка (бывает, называют master, но это неполиткорректно; ещё: trunk)
			Если по отношению к коммиту - то означает, что это крайний коммит ветки
	HEAD		Текущее состояние репозитория, указатель на текущий коммит
	HEAD~<n>	n-й предок HEAD'а
	HEAD~		То же, что и HEAD~1
	origin/main	Главная ветка на удалённом репозитории
	origin/HEAD	Указывает, что на гитхабе данный коммит текущий

	origin/<branchname> -- это т.н. ветки слежения. Ветки слежения — это ссылки на определённое 
	  состояние удалённых веток. Это локальные ветки, которые нельзя перемещать; Git перемещает 
	  их автоматически при любой коммуникации с удалённым репозиторием, чтобы гарантировать 
	  точное соответствие с ним. См.: https://git-scm.com/book/ru/v2/Ветвление-в-Git-Удалённые-ветки

git switch <ветка>	Переключиться на ветку (более новая и более уместная команда, 
				появилась в Гит2.0)
				Работает, если репозиторий не менялся с момента последнего коммитинга
git checkout <ветка>	Переключиться на ветку (более старая команда и используется для других целей,
				но здесь тоже полностью годится)
				Работает, если репозиторий не менялся с момента последнего коммитинга
git switch -	Переключиться на предыдущую ветку
git checkout -	То же самое
git branch		Показывает список локальных веток (текущая - зелёная и с *)
git branch -r		Показывает список веток с сервака (GitHub etc)
git branch -a		Показывает вместе и локальные ветки, и ветки с сервака
git branch <имя_ветки>  		Создание новой ветки <имя_ветки>, указывающей на текущий коммит
git branch <имя_ветки> <хэш_коммита>	Создание новой ветки <имя_ветки>, указывающей на коммит <хэш_коммита>
git checkout -b <имя_ветки>		Создать новую ветку и сразу же перключиться на неё (удобно!)
git branch -m [старое_имя_ветки] [новое_имя_ветки] 	Переименование ветки
	ВНИМАНИЕ! Если переименовывать свежесозданную ветку до первого её пушинга, то всё норм,
	но если переименовывать ветку, которая уже на серваке есть, то есть нюансы
	Подробнее об этих нюансах можно почитать здесь:
		https://git-scm.com/book/ru/v2/Ветвление-в-Git-Управление-ветками




 = = = Заливка на гитхаб (пушинг и т.д.) = = =

git push		Заливает (пушит) текущую ветку на гитхаб, если она там уже есть в каком-то виде
			Если нету, то работает следующая команда:
git push --set-upstream origin/<имя_ветки> <имя_ветки>
			Пушит новую ветку на гитхаб (и создаёт, и обновляет до последнего состояния)
git push -u origin/<имя_ветки> <имя_ветки>
			То же самое
git push --all		Пушит все ветки разом
git push --force	Форспушинг (см. далее)
git push -f		То же самое
git push --force-with-lease
			"Мягкий" форспушинг (см. далее)

	 = Форспушинг и "мягкий" форспушинг =
	Если поправить какие-нибудь старые коммиты в истории git, например: исправить имя автора или e-mail, 
	или отменить последний коммит или воспользоваться amend или revert, то git не даст сделать push
	В таком случае надо делать форспуш
	Но в этом случае мы рискуем перетереть чьи-нибудь изменения, если с тех пор, как мы забирали изменения 
	с сервера, кто-то успел запушить свои коммиты. Поэтому лучше использовать более безопасную команду
	git push --force-with-lease 
	Такой вариант лучше тем, что если кто-то успел запушить свои коммиты после того, как мы забирали 
	изменения с сервера, то он не будет их перетирать, а выдаст нам ошибку, после чего мы сможем 
	интегрировать чужие коммиты со своими изменениями и попытаться сделать push --force-with-lease ещё раз.
	Взято с: https://urvanov.ru/2017/09/19/опасность-git-push-force-и-полезность-git-push-force-with-lease/

	 = Защита от гита: .gitignore =
	Можно создать файл в папке проекта с именем ".gitignore", где можно перечислить всё, что не должно
	отслеживаться гитом. Например, туда стоит отправлять пучармовскую папку ".idea"
	с пучармовскими настройками проекта, т.к. другой человек возможно будет работать в другой IDE,
	у него там свои сопроводительные файлы, пучармовские ему ни к чему (свои аналогичные такие файлы 
	ему тоже следует добавить в .gitignore)




 = = = Мёржинг = = =

(не доизучено, доизучать!)

git cherry-pick <commit_hash>	берёт изменения, которые были сделаны в указанном коммите, 
					и накладывает на текущую ветку.
git merge 
git mergetool




 = = = Пуллинг = = =

(не доизучено, доизучать!)

git fetch	 привносит актуальность локальному репозиторию без 
			изменения его дерева или текущей ветки
git pull	связка последующих команд git fetch и git merge




 = = = Ребейзинг = = =

git rebase -i				Откроет файл, управляющий ребейзом (?)
git rebase --interactive 	То же самое

Раздел не дописан

Пара комментов с Хабра: https://habr.com/ru/articles/201922/
Главное в туториалах по rebase — не делайте этого с комитами, доступными не только вам.
То же касается и amend и вообще любых правок репозитория после того как сделан git push. 
 Кстати, об этом неплохо-бы написать в статье, пусть даже многие сервера и не принимают такие правки.
А ещё не делать git pull --rebase или git rebase после мержа веток.




 = = = Сравнение версий = = =

git diff		Показывает отличия текущей версим репозитория от последней заиндексированной или
				от последнего коммита, если индекс пуст
git diff --staged	Не совсем понял, надо будет уточнить получше, чё там с индексом xDDD




 = = = Информационные команды: = = =

git --version		Проверить текущую версию Git'а
git remote -v		Проверить текущие url'ы репозиториев
git status		Проверка текущего статуса: 
				в какой ветке сейчас локальный репозиторий
				какие файлы (не) заиндексированы (=(не) подготовлены к коммиту)
				какие файлы (не) закоммичены
git log			Показывает все коммиты текущей ветки
 ключи:	--all		Показывает все коммиты вообще
	--graph		Не просто перечисляет коммиты, но отрисовывает вложенную структуру
	--oneline	Кратко по каждому коммиту, только в одну строку (кусок хэша и коммент)
		(имеет смысл сразу все 3 штуки делать)
git blame <file>	Просмотреть, кто, что и когда изменил в <file>
				(инфа по каждой строке файла)
git reflog		Показать журнал изменений в заголовке локального репозитория. 
			Отличный вариант для поиска утраченных данных.

gitk			Запуск гуя. Покажет текущую ветку (вроде как, но это не точно)
gitk --all		Гуй покажет все ветки, построит строковое графическое дерево

git help		Подсказка гита
git <команда> --help	Открывает в браузере интернет-страничку с подробнейшей информацией по
				данной команде




 = = = Если вывод не помещается на страницу (например, от git log): = = =

Git хочет показать вам более одного экрана с информацией, для этого он вызывает стандартную
программу пейджера Unix less. Просто введите q, чтобы вернуться в терминал, когда вы больше не
хотите перемещаться по выходным данным.

q вернуться в терминал
j перейти на одну строку вниз
k переместиться на одну строку вверх
space перейти на одну страницу вниз
b перейти на одну страницу вверх
h показать помощь
/ поиск вперёд
? поиск назад

Внимание! Должна быть включена английская раскладка, с русской не работает!