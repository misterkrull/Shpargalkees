Хорошие статьи:
https://habr.com/ru/articles/174467/
https://habr.com/ru/companies/skillbox/articles/442260/
https://habr.com/ru/companies/yandex_praktikum/articles/768492/
https://habr.com/ru/companies/yandex_praktikum/articles/728302/
https://selectel.ru/blog/tutorials/git-fetch-command-how-is-it-different-from-git-pull/
https://habr.com/ru/articles/150001/
https://old.calculate-linux.org/main/ru/git




 = = = Начало работы с Git, с репозиторием = = =

Для работы с Git нужно текущую папку командной строки переместить в папку с проектом 
(внутри которой папка .git)

Можно пойти двумя путями:

git init		Создание репозитория в текущей папке (создаётся папка .git)
git clone <url>		Клонирование существующего репозитория (со всей его 
				историей) с Гитхаба на локальную папку

Лёша учил меня второму пути: сначала создать репозиторий на Гитхабе, потом его клонировать. 
Если через инит идти, то придётся потом настраивать origin (=удалённый репозиторий)

Важное замечание насчёт git clone: 
Нужно его писать, находясь не в репозитории проекта, а на уровень выше
(типа в папке, в которой будет создана папка с репозиторием)
Но после нужно зайти в эту папку через cd, далее в ней работать

Как "разгититься"? Удалить папку ".git"




 = = = Индексация (моими словами: прекоммит) = = =

index — область зафиксированных изменений, т.е. всё то, что вы 
	подготовили к сохранению в репозиторий.

git add <file>...	Заиндексировать файл(ы)
git add	.		Заиндексировать всю текущую папку
git add -A		Заиндексировать все изменения
git add --all		То же, что -A
	
	Замечание насчёт "git add .":
	Если текущая папка -- корневая папка репозитория, то "git add ." == "git add -A"
	Но если в репозитории есть поддиректории и если перейти в одну из них, 
		то вызов "git add ." заиндексирует только её содержимое
			
git restore --staged <file>...	Разыиндексировать файл(ы)

Если файл в проекте изменить, то он в гитстатус будет в красном списке
Если его заиндексировать, то он станет в зелёном списке
Если его снова изменить, то он будет и в красном, и в зелёном списке

Добавление в индекс файла, в котором нет изменений, ни к чему не приведёт




 = = = Коммитинг = = =

git commit -m <comment>				Закоммитить текущий индекс
git commit -am "First version of program"	Закоммитить все изменения в проекте (кроме добавления
						 новых файлов, при этом если что-то удалилось,
						 то будет закоммичено)

git checkout <commit hash>	Перевод состояния файлов к определённому коммиту (указывается либо его хэш либо любой иной указатель на этот коммит, если есть)
				Если начать коммитить отсюда, то получится "ветка" которая никак не называется, просто будет болтающийся сбоку коммит.
git revert <commit hash>	Отмена изменений коммита
				При этом создаётся новый коммит и всё сохраняется
					(подробней о сравнении - в моей истории в LearnGPT
					топик Computer Science/Введение)
				Дописывает в коммент, что произошёл реверт
git commit --amend		Исправить коммент к последнему коммиту
					(работает только для последнего, остальные уже не исправить;
					ещё условие: работает, если ничего не проиндексировано
					ещё условие: работает, если ещё не запушил последний коммит:
						если запушил и потом аменд сделал, то пуш не выйдет,
						но можно сделать форспуш (см. Пушинг))
						

P.S. Отдельно git commit работает, кажется, как git status




 = = = Работа с ветками = = =

Всякие названия: 
	origin		Название удалённого репозитория. Или того, с которого сделал clone.
			Хрен его знает, как точно, но примерно так
	main		Главная ветка (бывает, называют master, но это неполиткорректно; ещё: trunk)
			Если по отношению к коммиту - то означает, что это крайний коммит ветки
	HEAD		Текущее состояние репозитория (относится к коммиту)
	origin/main	Главная ветка на удалённом репозитории
	origin/HEAD	Указаывает, что на гитхабе данный коммит текущий


git switch <ветка>	Переключиться на ветку (более новая и более уместная команда, 
				появилась в Гит2.0)
git checkout <ветка>	Переключиться на ветку (более старая команда и используется для других целей,
				но здесь тоже полностью годится)
git branch		Показывает список веток (текущая - зелёная и с *)
git branch <новая ветка>  Создание новой ветки




 = = = Заливка на гитхаб (пушинг и т.д.) = = =

git push		Заливает (пушит) текущую ветку на гитхаб, если она там уже есть в каком-то виде
			Если нету, то работает следующая команда:
git push --set-upstream origin <имя_ветки>
			Пушит новую ветку на гитхаб (и создаёт, и обновляет до последнего состояния)
git push --force	Форспушинг (см. далее)
git push -f		То же самое
git push --force-with-lease
			"Мягкий" форспушинг (см. далее)

	Форспушинг и "мягкий" форспушинг
	Если поправить какие-нибудь старые коммиты в истории git, например: исправить имя автора или e-mail, 
	или отменить последний коммит или воспользоваться amend или revert, то git не даст сделать push
	В таком случае надо делать форспуш
	Но в этом случае мы рискуем перетереть чьи-нибудь изменения, если с тех пор, как мы забирали изменения 
	с сервера, кто-то успел запушить свои коммиты. Поэтому лучше использовать более безопасную команду
	git push --force-with-lease 
	Такой вариант лучше тем, что если кто-то успел запушить свои коммиты после того, как мы забирали 
	изменения с сервера, то он не будет их перетирать, а выдаст нам ошибку, после чего мы сможем 
	интегрировать чужие коммиты со своими изменениями и попытаться сделать push --force-with-lease ещё раз.
	Взято с: https://urvanov.ru/2017/09/19/опасность-git-push-force-и-полезность-git-push-force-with-lease/

	Защита от гита: .gitignore
	Можно создать файл в папке проекта с именем ".gitignore", где можно перечислить всё, что не должно
	отслеживаться гитом. Например, туда стоит отправлять пучармовскую папку ".idea"
	с пучармовскими настройками проекта, т.к. другой человек возможно будет работать в другой IDE,
	у него там свои сопроводительные файлы, пучармовские ему ни к чему (свои аналогичные такие файлы 
	ему тоже следует добавить в .gitignore)




 = = = Мёржинг = = =

(не доизучено, доизучать!)

git cherry-pick <commit_hash>	берёт изменения, которые были сделаны в указанном коммите, 
					и накладывает на текущую ветку.
git merge
git rebase 




 = = = Пуллинг = = =

(не доизучено, доизучать!)

git fetch	 привносит актуальность локальному репозиторию без 
			изменения его дерева или текущей ветки
git pull	связка последующих команд git fetch и git merge




 = = = Ребейзинг = = =

git rebase -i				Откроет файл, управляющий ребейзом (?)
git rebase --interactive 	То же самое

Раздел не дописан

Пара комментов с Хабра: https://habr.com/ru/articles/201922/
Главное в туториалах по rebase — не делайте этого с комитами, доступными не только вам.
То же касается и amend и вообще любых правок репозитория после того как сделан git push. 
 Кстати, об этом неплохо-бы написать в статье, пусть даже многие сервера и не принимают такие правки.
А ещё не делать git pull --rebase или git rebase после мержа веток.




 = = = Информационные команды: = = =

git --version		Проверить текущую версию Git'а
git remote -v		Проверить текущие url'ы репозиториев
git status		Проверка текущего статуса: 
				в какой ветке сейчас локальный репозиторий
				какие файлы (не) заиндексированы (=(не) подготовлены к коммиту)
				какие файлы (не) закоммичены
git log			Показывает все коммиты текущей ветки
 ключи:	--all		Показывает все коммиты вообще
	--graph		Не просто перечисляет коммиты, но отрисовывает вложенную структуру
	--oneline	Кратко по каждому коммиту, только в одну строку (кусок хэша и коммент)
		(имеет смысл сразу все 3 штуки делать)
git diff		Сравнивает чего-то с чем-то. Много параметров. Гугли отдельно.
git blame <file>	Просмотреть, кто, что и когда изменил в <file>
				(инфа по каждой строке файла)
git reflog		Показать журнал изменений в заголовке локального репозитория. 
			Отличный вариант для поиска утраченных данных.

gitk			Запуск гуя. Покажет текущую ветку (вроде как, но это не точно)
gitk --all		Гуй покажет все ветки, построит строковое графическое дерево

git help		Подсказка гита


	Если вывод не помещается на страницу (например, от git log):

Git хочет показать вам более одного экрана с информацией, для этого он вызывает стандартную
программу пейджера Unix less. Просто введите q, чтобы вернуться в терминал, когда вы больше не
хотите перемещаться по выходным данным.

j перейти на одну строку вниз
k переместиться на одну строку вверх
space перейти на одну страницу вниз
b перейти на одну страницу вверх
h показать помощь
/ поиск вперёд
? поиск назад