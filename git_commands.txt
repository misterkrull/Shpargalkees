Хорошие статьи:
https://habr.com/ru/articles/174467/
https://habr.com/ru/companies/skillbox/articles/442260/
https://habr.com/ru/companies/yandex_praktikum/articles/768492/
https://habr.com/ru/companies/yandex_praktikum/articles/728302/
https://selectel.ru/blog/tutorials/git-fetch-command-how-is-it-different-from-git-pull/
https://habr.com/ru/articles/150001/
https://old.calculate-linux.org/main/ru/git
https://webhamster.ru/mytetrashare/index/mtb0/1465119902140pozfhh1
https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/

Игра по Гиту: https://learngitbranching.js.org/?locale=ru_RU




 = = = Начало работы с Git, с репозиторием = = =

Для начала работы с Git нужно создать репозиторий. Это можно сделать двумя способами:
 1) превратить какую-либо директорию на компьютере в репозиторий
 2) склонировать удалённый репозиторий на свой копмьютер

	Чем папка (директория) отличается от репозитория? 
	Репозиторий -- это папка, которая отслеживается Git'ом. Признаком этого является
	  наличие в ней подпапки .git
	Всякий репозиторий является директорией, но не всякая директория -- репозиторий.
    Working tree (рабочая директория) -- это репозиторий за вычетом папки .git,
      т.е. те самые файлы и папки, за которыми следит Гит.

Способ первый.
  Мы должны текущим рабочим каталогом командной строки сделать папку с проектом. 
  ВНИМАНИЕ! Саму папку, а не каталог, её содержащий (что относится скорее ко второму способу)
  Затем надо ввести команду git init
  Она превратит текущую папку в репозиторий Git'а, создав при этом подпапку .git
  Всё, можно работать с гитом прям из этой директории 
    (т.е. не надо делать cd, в отличие от второго способа)

Способ второй.
  Мы должны текущим рабочим каталогом командной строки сделать папку, которая будет 
    содержать будущий репозиторий
  ВНИМАНИЕ! В отличие от первого способа, здесь мы как бы отправляемся уровнем выше,
    в наддиректорию. Ну хотя бы по той причине, что пока ещё нет директории репозитория.
    Самостоятельно создавать новую директорию тоже не надо, она будет создана автоматически.
    Просто надо быть на уровень выше.
  Далее пишем следующую команду:
    git clone <url>
	где <url> -- это адрес удалённого репозитория. В ГитХабе его можно найти следующим образом:
	зайти на страничку репозитория и вверху справа найти зелёную кнопку с надписью "<> Code". 
	Там на вкладке Local на подвкладке HTPPS будет текстовое поле с адресом, который нужно 
 	скопировать (есть даже специальная кнопка) -- это и будет нужным нам url'ом. 		
  Команда git clone создаст новую директорию с именем удалённого репозитория и скопирует в неё всё
    его содержимое (вместе с папкой .git, разумеется)
  Далее нужно будет перевести текущий рабочий каталог командной строки в эту директорию (с помощью
    комнады cd, например)
  Всё, можно работать.
  ПРИМЕЧАНИЯ:
    1) По умолчанию в процессе клонирования удалённому репозиторию присваивается имя origin
       Однако при клонировании можно задать другое имя, для этого следует использовать:
       git clone -o <newname> <url>
    2) Также по умолчанию репозиторий клонируется в папку, называющуюся так же, как удалённый
       репозиторий. Но можно имя папки поменять (например, чтобы создать копию репозитория для
       работы с двумя ветками параллельно). Для этого годится следующая команда:
         git clone <url> <имя_папки>

Лёша учил меня второму способу.
Говорил, что в первом способе ещё придётся потом настраивать origin (=удалённый репозиторий),
  что пока что я плохо представляю, как делать
  (хотя на данный момент у меня до сих пор возникают проблемы с этим origin и после второго 
  способа... м-да)


Как "разгититься"? Удалить папку ".git"

Как понять, в репозитории мы находимся или в папке?
Самый простой способ это сделать — набрать в терминале команду «git status». Если в ответ вы увидите 
ошибку «fatal: not a git repository (or any of the parent directories): .git», значит, в терминале
вы вызываете команду не из репозитория, а из обычной папки. Если вы увидели что-то другое, 
то вы находитесь в репозитории или внутри одной из папок, которая находится в нём (в частности, если
вы вызовите git status из папки .git, то получите следующее сообщение: «fatal: this operation must 
be run in a work tree»; вызов же из "нормальных" папок будет более привычным и адекватным).


Хорошая статья по этой теме: https://habr.com/ru/articles/718830/




 = = = Индексация = = =

index (=staging area =cache) — область зафиксированных изменений, т.е. всё то, 
	что вы подготовили к сохранению в репозиторий.

git add <file>...	Заиндексировать файл(ы)
git add	.			Заиндексировать всю текущую папку
git add -A			Заиндексировать все изменения
git add --all		То же, что -A
git add -f <file>	Добавить файл принудительно (даже если он есть в .gitignore)
	
	Замечание насчёт "git add .":
	Если текущая папка -- корневая папка репозитория, то "git add ." == "git add -A"
	Но если в репозитории есть поддиректории и если перейти в одну из них, 
		то вызов "git add ." заиндексирует только её содержимое
	
	Замечание насчёт пустых папок.
	Гит не видит пустые папки... по историческим причинам :)

	Замечание насчёт удаляемых файлов:
	Если мы удалили файлы из репозитория, то чтобы Гит тоже считал их удалёнными, нужно
	  закоммитить их удаление, а прежде -- заиндексировать! Иначе Гит не запишет удаление 
	  в свою историю и будет в git status отображать такие файлы в списке Changes not 
	  staged for commit красным цветом с пометой deleted.
	Удалившиеся файлы можно индексировать как с помощью "git add <file>", так и 
	  с помощью "git add .". Также они автоматически будут добавляться в коммит при 
	  выполнении команды git commit -a
	При этом с точки зрения операционной системы такие файлы уже, естественно,
	  не существуют, поэтому ввести их имена в командной строке с помощью Tab-подсказки 
	  не выйдет, однако ручной корректный ввод несуществующего файла будет корректно 
	  обработан, т.к. Git-то его помнит!
			
	git rm <file>...				Удалит файл и сведения об удалении положит в индекс
										(с флагом -r можно и для папок)
	git mv <old> <new>				Переименует/переместит файл и сообщит об этом в индекс

Как разиндексировать файл(ы)? См. далее главу "Отмена действий"
(Также там написаны ещё некоторые возможности команды git rm)

Добавление в индекс файла, в котором нет изменений, ни к чему не приведёт.

Во время конфликтов слияния индекс начинает вести себя необычно, у него появляются некие "слоты".
Подробнее см. в главе про конфликты слияния.


     = = = Индексация файла по частям: git add -p = = =
  
    git add -p или git add --patch
    Открывает интерактивный интерфейс. 
    Проходит по диффу файла между текущей и последней заиндексированной/закоммиченной
      версией, отделяет друг от друга куски, между которыми как минимум 7 неизменных
      строк, спрашивает по каждому куску:
  	y - индексировать этот кусок
  	n - не индексировать этот кусок
  	q - выйти (в индексе останется всё, что успели внести в индекс)
  	a - индексировать этот кусок и все последующие куски в файле
  	d - не индексировать этот кусок и все последующие куски в файле
  	? - вывести справку
  	s - разделить этот кусок ещё сильнее:  не через 7 неизменных строк, а через 1
  	e - внести изменения в текущем куске вручную (откроется сторонний редактор)
		  Комментарий по поводу последнего пункта "e":	
			Сделанные в редакторе изменения попадут только в индекс, но не в текущую версию.
			  (туда они попадут только через git restore <file> или через коммит и хардресет, см.ниже)
			Таким образом, в индексе может оказаться информация, которой нет ни в текущей версии, 
			  ни в последней закоммиченной.
			Команда полезна, если Git разметил дифф не так, как нам хотелось бы, но при её использовании
			  нужно быть аккуратным и понимать, что есть какие-то отличия, которых нет в текущей версии файла.
			Ещё момент: если мы, скажем, в git add -p исправляем последнее отличие текущей версии от индекса
			  и вызываем эту команду "e", затем пишем что-то в редакторе, то в итоге файл не пропадёт из
			  красного списка в git status (как было бы, если б мы просто добавили данное отличие в индекс).
			  Однако теперь в зелёном списке (т.е. в индексе) будет более свежая версия, чем в красном
			  (где текущая), хотя в "обычном" сценарии наоборот: в красном списке версия свежее и нужно
			  обновлять индекс через add. Здесь же можно:
			   1) текущую версию файла подобновить из индекса: git restore <file>
			   2) забить на красный список, делать коммит, а потом делать хардресет, чтобы
					убрать старую текущую версию и влить в неё изменения, сделанные через "e"
					(хотя вместо хардресета опять-таки сгодится git restore <file>)
			Однако если это было не последнее отличие в диффе, а впереди у нас ещё много изменений
			  нашего файла, которые нужно коммитить по отдельности, то добавленные через "e" правки
			  в текущей версии просто так не увидишь, их нужно держать в голове либо:
			    - делать git stash push (а после просмотра -- git stash pop) -- покажет нам коммит;
			      - если не делал коммит, то просмотреть индекс можно после git stash push -k;
			    - смотреть в сторонних программах содержание индекса или коммита;
			    - делать git push и смотреть в remote.
			

    Хорошая статья по теме: https://nuancesprog.ru/p/7502/ 




 = = = Статусы файлов в Гите = = =

untracked	Файл не отслеживается Гитом: ни разу не индексировался (свежедобавленный)
tracked		Файл отслеживается Гитом (тут и закоммиченные, и только проиндексированные)
staged		Файл заиндексирован
modified	Файл отличается от последней закоммиченной версии


	 = = Списки в гитстатусе = = 
	
	Untracked files
		список неотслеживаемых (untracked) файлов, помечается красным
	Changes not staged for commit
		список файлов с непроиндексированными изменениями (modified),
		    помечается словом modified и красным - если файл был изменён
		    помечается словом deleted и красным - если файл был удалён
	Changes to be committed
		список индексированных (staged, modified) файлов, 
		    помечается словом modified и зелёным - если индексировался ранее - ИЛИ
		    помечается словами new file и зелёным - если новый файл
		    помечается словом deleted и красным - если файл был удалён


	Если файл в проекте изменить, то он будет в Changes not staged for commit
	Если его заиндексировать, то он будет в Changes to be committed
	Если его снова изменить, то он будет и там, и там
		(при этом коммит на текущем этапе закоммитит только проиндексированную
		    версию, а git restore откатит тоже к индексированной версии,
		    и в этих обоих случаях из списка Changes to be committed файл пропадёт)
	
	Если все те три списка пусты, то гитстатус выводит вот это:
		On branch krull_fixes
		[Your branch is up to date with 'origin/<...>'.]
		nothing to commit, working tree clean
			(нечего коммитить, рабочая директория чиста)




 = = = Отмена действий = = =

git restore <file>...			Отменить все неиндексированные изменения в файле(-ах)
git restore -W <file>			То же самое
git restore .					Отменить все неиндексированные изменения во всех отслеживаемых файлах 
									в текущей папке	(см. также git reset)

git restore --staged <file>...	Разыиндексировать файл(ы)
git restore -S <file>...		То же самое
git reset <file>...				То же самое
git rm --cashed <file>...		То же самое
git rm -r --cashed <dir>...	  	То же самое (но для папок)

git restore -S .				Разындексировать все файлы из текущей директории
git reset						Разындексировать ВСЕ файлы

Обрати внимание: git restore не меняет индекс, но меняет сам файл в репозитории, а git restore -S наоборот
меняет индекс, но сам файл в репозитории остаётся неизменным.

Если мы что-то поменяли в репозитории, наиндексировали, ещё раз поменяли и т.д., а потом решили откатить
репозиторий к последнему коммиту, то по идее надо сначала всё сперва разыиндексировать, потом 
все неиндексированные (т.е. ещё незаиндексированные и уже разындексированные) изменения отменить.
Логика подсказывает использовать "git restore -S .", затем "git restore .". Их можно объединить:

git restore -SW .		Отментить вообще все изменения в текушей папке, откатить до последнего коммита
						(эта команда не тронет лишь свежедобавленные и потому неотслеживаемые файлы)
					(да, ради этого я выше описал команду git restore -W)
Однако никто так не делает, ибо для этого есть git reset --hard: см. далее


git reset [--soft | --mixed | --hard] [<commit>]	Откат состояния к данному коммиту

git reset может содержать указатель на коммит (в таком случае мы перейдём к тому коммиту),
	а может и не содержать (тогда перейдём к текущему коммиту)
git reset тащит за собой указатель на текущую ветку (!!!)

git reset бывает трёх видов:
  1) --soft:
	Откатывает до коммита, а все изменения между новым и старым коммитами пишет в индекс (т.е. в staged)
	С самим репозиторием ничего не происходит, с изначальным индексом тоже ничего не происходит (разве что
	к нему возможно прибывает пополнение), изначальный список unstaged-изменений тоже остаются как был
  2) --mixed (делается по умолчанию, если не указывается флаг): 
	Откатывает до коммита, а все изменения между новым и старым коммитами пишет в unstaged,
	а всё, что изначально было в индексе, разындексирует -- т.е. тоже в unstaged
	Изначальные unstaged-измнения остаются как были (разве что к ним возможно прибывает пополнение)
	С репозиторием по-прежнему ничего не происходит
  3) --hard:
	Откатывает до коммита, а все изменения нафиг стирает, соответсвенно репозиторий откатывается
	к состоянию на момент того коммита (за исключением лишь недавно добавленных в репозиторий
	неотслеживаемых (untracked) файлов, их хардресет не замечает и потому не трогает; наличие таковых --
	единственное, что отличает состояние репозитория после хардресета от состояния того коммита, на
	который делается хардресет).
	Весь изначальный индекс и все изначальные незакоммиченные изменения нафиг уничтожаются БЕЗВОЗВРАТНО!
		(помимо уже упомянутых untracked-файлов)
	ВНИМАНИЕ! Перед выполнием всегда проверять с помощью git status, есть ли изменения (заиндексированные
	или нет), потому что в результате действия хардресета они пропадут БЕЗВОЗВРАТНО! ну если конечно они
	нам нужны :) А если снести эти изменения наша цель, то таки да, хардресет наше всё :))
	ВНИМАНИЕ! Если делать хардресет на коммит, отличный от текущего, то с текущего коммита уйдёт текущая
	ветка. Если на этот коммит указывала только эта ветка и не указывали никакие другие ветки даже
	опосредованно через иные коммиты, то в результае выполнения git reset --hard этот бывший текущий коммит
	становится висящим (т.е. на него не указывает ни одна ветка), вместе с ним висящими становятся и все
	его предки вплоть невключительно до того коммита, на который хоть какая-то ветвь всё же указывает --
	в результате все эти коммиты пропадут из git log, добраться до них можно будет только через git reflog

Замечания:
  git reset --soft без указания на коммит (или, что тоже самое, с указанием на текущий коммит) не делает ничего
  git reset без указания на коммит аналогичен действию git restore -S . (если мы в корневой папке репозитория),
	т.е. тупо очищает индекс
  git reset --hard без указания на коммит обнуляет все измненения (заиндексированные и нет) в репозитории,
	т.е. действует как git restore -SW . (опять-таки, если мы в корневой папке репозитория); исключение
	составляют лишь свежедобавленные и потому неотслеживаемые файлы
  git reset --hard <commit> похож по действию на git checkout <commit>, вот только первый тащит за собой
	текущую ветку, а второй оставляет её там, где была. Но с репозиторием происходит одно и то же.
	ВНИМАНИЕ! У обоих способов есть проблемки: у чекаута -- оторванная башка, опасная тем, что может
	впоследствии породить висящие пропащие коммиты, хардресет же может сразу один или несколько коммитов
	сделать висящими. Подробнее об этом -- в справке по каждой команде.
  git reset --hard HEAD~ удаляет последний коммит.
  Когда git reset перемещает ветку, то она записывает предыдущее значение HEAD в файл ~/.git/ORIG_HEAD

Хорошая небольшая статья про git reset: https://habr.com/ru/articles/203282/

git checkout <хэш> <file>...		Из указанного коммита достанет версию указанного файла и поместит её 
										в текущий индекс (состояние репозитория не переключит)


	 = = = Как быть с неотслеживаемыми файлами/папками = = =

	Если хочется очистить каталог от всякой незакоммиченной шушеры, то можно делать git reset --hard,
	однако это не повлияет на неотслеживаемые файлы и папки
	
	Чтобы очистить репозиторий от этого мусора, нужно выполнить следующую команду:
		git clean -f
		  доп. флаги:
			-d 	без этого флага удалит только файлы корневой папки, с ним - все файлы и папки
			-x 	с этим флагом почистит даже то, что указано в .gitignore




 = = = Коммитинг = = =

git commit					Закоммитить текущий индекс (откроется сторонний текстовый редактор 
								для написания комментария)
git commit -m <comment>		Закоммитить текущий индекс (комментарий указывается прям здесь в кавычках,
								а если он одним словом без пробелов, то можно и без кавычек)
git commit -a				Закоммитить все изменения в проекте 
							(кроме добавления новых файлов, т.к. они untracked;
							при этом удаления новых файлов будут закоммичены, т.к. они tracked)
git commit -am <comment>	Комбо из предыдущих двух; довольно ходовая команда :)
git commit <file>...		Закоммитить указанный(е) файл(ы) напрямую из репозитория в обход индекса; 
								при этом с индексом и с unstaged ничего не происходит (если не считать
								самого этого файла(ов): он(и) убирается и из индекса, и из unstaged).
								Можно также добавить -m с комментом (перед файлом(ами))
								Внимание: не работает для новых неотслеживаемых файлов!

  ЗАМЕЧАНИЯ:
  1. Если индекс пуст, то команды <git commit>, <git commit -m "smthng"> работают так же, как <git status>.
     Команда <git commit -a> в случае пустого индекса, но непустого списка изменений работает как полагается 
       (всё индексирует + всё коммитит), но в случае пустого списка изменений всё-таки работает как <git status>
       (ну то есть выдаёт слова "On branch <ветка> // nothing to commit, working tree clean") 
  2. Если делать коммит через сторонний редактор, есть возможность отменить процесс коммитинга.
     Просто нужно написать пустое сообщение в коммит -- всё, операция отменится.
  3. Хорошим тоном является добавление в коммент коммита номера выполняемой задачи.
     Если работать с GitHub'ом, то там задачу нужно указывать в виде #<номер задачи>
     Если ставить это дело в самое начало коммента, то при работе в стороннем редакторе символ # воспримется
       как служебный: в самом деле, в редакторе полно строк, начинающихся с #, по всей видимости они 
       воспринимаются как игнорируемые; в таком случае и написанный нами коммент будет проигнорируем,
       Гит сочтёт коммент пустым и согласно предыдущему замечанию коммитинг тупо отменится
     Но всё-таки можно начать коммент с #: надо просто перед ним поставить дополнительный пробел, который,
       к слову, в коммент как ни странно не попадёт и сам коммент начнётся с #, чтд.
  4. Если хотим написать сообщение в коммит на нескольких строках, то нужно вторую строку сделать пустой.
	 Таким образом первая строка будет проинтерпретирована как заголовок коммита, а третья и последующие --
	   как обычный текст. (Но как правило обходимся одной строкой, конечно же)

git commit --amend				Исправить последний коммит
								(работает только для последнего, остальные уже не исправить)
								Также можно добавить флаги -a, -m  или -am (см. выше)
git commit --amend --no-edit	Исправить последний коммит, но не трогать при этом коммент

	ВНИМАНИЕ! Если исправлять уже запушенный коммит, то потом пуш просто так не получится, 
	  но можно сделать форспуш (подробнее см. Пушинг)









 = = = Всякие названия, сокращения = = = 

origin			Имя удалённого репозитория, с которого сделал clone.
					Это имя "origin" даётся автоматически по умолчанию, однако вместо него
					можно задать другое имя, если вместо git clone <url> написать 
					git clone -o <newname> <url> при изначальном клонировании репозитория.
main			Главная ветка (бывает, называют master, но это неполиткорректно; ещё: trunk)
					Если по отношению к коммиту - то означает, что это крайний коммит ветки
<hash>~<n>		n-й предок коммита (по главной линии: каждый родитель -- первый, если их несколько)
<hash>~			То же, что и <hash>~1
<hash>^<n>		n-й родитель коммита (относится к мёрж-коммитам, у которых несколько родителей)
<hash>^			первый родитель коммита -- то же самое, что и <hash>~
HEAD			Текущее состояние репозитория, указатель на текущий коммит
@				То же самое (но вроде не любая ОС интерпретирует этот символ верно)
HEAD~<n>		n-й предок HEAD'а
HEAD~			То же, что и HEAD~1

HEAD@{<n>}			Указывает на хэши коммитов по списку в reflog, т.е. это коммит, куда HEAD
						указывал n шагов назад по истории переключений HEAD'а (т.е. по reflog'у)
<branch>@{<n>}		То же самое, но по рефлогу для ветки <branch>
@{<n>}				То же самое, но по рефлогу для текущей ветки

origin/<branchname> -- это т.н. ветки слежения. Ветка слежения — это ссылка на определённое 
  состояние удалённой ветки. Это локальные ветки, которые нельзя перемещать; Git перемещает 
  их автоматически при любой коммуникации с удалённым репозиторием, чтобы гарантировать 
  точное соответствие с ним. См.: https://git-scm.com/book/ru/v2/Ветвление-в-Git-Удалённые-ветки
origin/main			Главная ветка на удалённом репозитории
origin/HEAD			Указывает, что на удалённом репозитории данный коммит текущий




 = = = Работа с ветками = = =
 
git branch				Показывает список локальных веток (текущая - зелёная и с *)
  флаги: -r				Показывает список веток с сервака (GitHub etc)
		 -a				Показывает вместе и локальные ветки, и ветки с сервака
		 -v				Показывает вместе с ветками и информацию о коммитах, на которые они указывают
		 -vv			Показывает список связей локальных веток с upstream-ветками
		 --merged		Показывает все ветки, которые когда-либо были смёржены с текущей
		 --no-merged	Показывает все ветки, которые никогда не были смёржены с текущей

git branch <имя_ветки>  Создать новую ветку <имя_ветки>, указывающую на текущий коммит
							Название ветки в Git может состоять из букв, цифр, а также включать
							любой из четырёх символов: ., -, _, /. Эти символы не несут особого смысла. 
git branch <имя_ветки> <хэш_коммита>
						Создать новую ветку <имя_ветки>, указывающую на коммит <хэш_коммита>

git switch <ветка>		Переключиться на ветку (более новая и более уместная команда, 
						  появилась в Гит2.0)
git checkout <ветка>	Переключиться на ветку (более старая команда и используется для других целей,
						  но здесь тоже полностью годится)
git switch -			Переключиться на предыдущую ветку
git checkout -			То же самое

	Переключение веток работает, если пусты modified и staged. Если не пусты, то выдаст ошибку. 
	Если нужно всё-таки переключиться и похерить изменения, можно использовать ключ -f
	ВНИМАНИЕ! Есть ситуации, где переключение веток происходит несмотря на изменения в репозитории! 
	  Так будет, если изменения относятся только к тем файлам, которые не отличаются в исходной 
	  и новой ветках. В таком случае эти изменения переходят на новую ветку! 
	  Гит об этом сообщает, по каждому файлу с изменениями пишет по одной строке вида:
	  M		<filename>

git switch -c <имя_ветки> [<хэш_коммита>] 			Создать новую ветку и сразу же перeключиться на неё
git checkout -b <имя_ветки>	[<хэш_коммита>]			то же самое

git branch -m [новое_имя_ветки]						Переименовать текущую ветку
git branch -m [старое_имя_ветки] [новое_имя_ветки] 	Переименовать любую ветку
	ВНИМАНИЕ! Если переименовывать свежесозданную ветку до первого её пушинга, то всё норм,
	но если переименовывать ветку, которая уже на серваке есть, то есть нюансы
	Подробнее об этих нюансах можно почитать здесь:
		https://git-scm.com/book/ru/v2/Ветвление-в-Git-Управление-ветками

git reset --hard <хэш_коммита>			Переставить указатель текущей ветки на коммит
  (Разумеется, перед хардресетом надо проверить, нет ли незакоммиченных изменений, которые не хочется терять)
git branch -f <ветка> <хэш_коммита>		Переставить указатель НЕ текущей ветки на коммит (либо создать ветку,
											если не создана); с текущей не сработает, выдаст ошибку
git switch -C <ветка> <хэш_коммита>		Переставить указатель любой (и текущей, и не текущей) ветки на коммит
											(либо создать эту ветку, если не создана) и перейти на неё
git checkout -B <ветка> <хэш_коммита>	То же самое

git branch -d <ветка>		Удалить ветку. Работает только если есть какая-то другая ветка, которая
								указывает на тот же коммит, что и данная ветка (т.е. чтобы в результате
								удаления не появились висящие недостижимые коммиты), при этом та другая 
								ветка должна локальной, origin-ветки не сканают. Также не работает, если
								удаляемая ветка -- текущая. 
git branch -D <ветка> = git branch -d -f <ветка>	Принудительно удалить ветку, т.е. несмотря на сказанное
													выше (однако текущую ветку всё равно не удалит)
	Удаление ветки из локального репозитория не удаляет её из origin!
	Локальная ветка и ветка с origin удаляются независимо по отдельности!
	Для удаления с origin есть следующие команды:
		git push -d origin <имя_ветки>
		git push origin :<имя_ветки>
	(после такого из GitHub ветка пропадает, а если найти на неё ссылку где-нибудь в каком-нибудь 
	  пулл-реквесте, то будет ошибка 404)


Можно также переключаться не на какую-то ветку, а напрямую на коммит:
	git checkout <commit>	Перевод состояния репозитория (т.е. указателя HEAD) к данному коммиту 
								(указывается его хэш или любой иной указатель на этот коммит, если есть)
								Работает, если репозиторий не менялся с момента последнего коммитинга
Однако тут возникает не очень хорошее состояние отрыва башки...


	 = = = О состоянии detached HEAD = = =
	
	Как правило, HEAD не указывает напрямую на какой-либо коммит. Он указывает на какую-то ветку, а вот
		ветка уже указывает на коммит. В логе об этом указывается так: "HEAD -> branchname".
	Но такое случается не всегда.
	
	Бывает, что HEAD указывает напрямую на коммит. Такое состояние называется detached HEAD (по-русски:
		отсоединённый HEAD, оторванная голова/башка).
	
	Такое возникнет, если мы сделаем checkout напрямую на коммит.
	В том числе такое возникнет, даже если мы сделаем checkout на коммит, на который указывает какая-либо ветка.
		Если мы хотим переключиться на какую-то ветку, то должны прямо указывать эту ветку!
		Если же вместо неё указать коммит, на который она указывает, то мы переключимся на сам коммит,
			и HEAD будет указывать на него, а не на ветку. Получим detached HEAD.
		В таком случае в логе будет написано не "HEAD -> branchname", а "HEAD, branchname".

	В состоянии отрыва башки:
		команда git status выдаёт "HEAD detached at <commit hash>",
			причём красным цветом;
		Git Bash в конце строки приглашения вместо имени ветки в скобках пишет хэш текущего коммита, 
			но уже в двойных скобках!
	
	По-хорошему репозиторий не должен долго находиться в таком состоянии. Тут вижу два варианта действий:
	  1) Если мы просто зашли посмотреть на коммит: посмотрели и возвращаемся обратно на ту ветку, где были
	  2) Если мы захотели отпочковаться от данного коммита: первым делом следует создать здесь 
		новую ветку, затем не забыть(!) на неё переключиться (или одним выстрелом двух зайцев с помощью
		git checkout -b) -- тем самым мы выйдем из состояния оторванной башки; 
		далее можно коммитить в эту ветку сколько угодно

	Хорошая статья по теме: https://webhamster.ru/mytetrashare/index/mtb0/1465119902140pozfhh1
	(в т.ч. см. там причину, почему оторванный HEAD -- зло)

	Замечание.
	git checkout HEAD@{0} отсоединит HEAD от текущей ветки и направит его напрямую на коммит. Будет
	  состояние detached HEAD. Однако git checkout HEAD или git checkout @ не сделает ничего -- это 
	  весьма странно, учитывая, что git rev-parse на HEAD, @ и HEAD@{0} выдаёт одинаковые хэши...
	  Может дело в том, что на @ стоит ветка? но если на @~1 стоит какая-то ветка, то git checkout @~1
	  всё равно отрывает башку... странно короче.




 = = = Пушинг = = =

git push	Заливает (пушит) текущую ветку на гитхаб, если она там уже есть и корректно настроена
				связь между ней и соответсвующей ей удалённой веткой

			Если нету и/или не настроена связь, то нужно выполнить следующую команду:
git push --set-upstream origin <имя_ветки>
			Пушит новую ветку на гитхаб (и создаёт, и обновляет до последнего состояния, и 
			  связывает локальную ветку с удалённой)
git push -u origin <имя_ветки>			То же самое
git push -d origin <имя_ветки>			Удаляет ветку из origin
git push origin :<имя_ветки>			То же самое  (пробел перед : важен!)	

git push --all	  Пушит все ветки разом
			(Причём каким-то образом пушит даже те ветки, у которых связь не настроена...
			Не совсем понимаю, почему так происходит, ну и ладно: надо просто всегда
			ветки нормально связывать, вот и всё)
git push -u origin --all
				  Пушит все ветки разом и сразу им ещё и связь настраивает
	ВНИМАНИЕ! Не стоит повсеместно прибегать к этим двум командам, т.к. на локалке могут заваляться
	  всякие старые ненужные ветки, лить их на сервак ни к чему, ибо они там -- мусор, который ещё 
	  удалять придётся. Лучше пушить по одной ветке.

git push --force				Форспушинг (см. далее)
git push -f						То же самое
git push --force-with-lease		"Мягкий" форспушинг (см. далее)

	 = = = Форспушинг и "мягкий" форспушинг = = =
	Если поправить какие-нибудь старые коммиты в истории git, например: исправить имя автора или e-mail, 
	или отменить последний коммит или воспользоваться amend или revert, то git не даст сделать push
	В таком случае надо делать форспуш
	Но в этом случае мы рискуем перетереть чьи-нибудь изменения, если с тех пор, как мы забирали изменения 
	с сервера, кто-то успел запушить свои коммиты. Поэтому лучше использовать более безопасную команду
	git push --force-with-lease 
	Такой вариант лучше тем, что если кто-то успел запушить свои коммиты после того, как мы забирали 
	изменения с сервера, то он не будет их перетирать, а выдаст нам ошибку, после чего мы сможем 
	интегрировать чужие коммиты со своими изменениями и попытаться сделать push --force-with-lease ещё раз.
	Взято с: https://urvanov.ru/2017/09/19/опасность-git-push-force-и-полезность-git-push-force-with-lease/




 = = = Защита от Гита: .gitignore = = =

Можно создать файл в папке проекта с именем ".gitignore", где можно перечислить всё, что не должно отслеживаться 
Гитом. Например, туда стоит отправлять пучармовскую папку ".idea" с пучармовскими настройками проекта, т.к. 
другой человек возможно будет работать в другой IDE, у него там свои сопроводительные файлы, пучармовские ему 
ни к чему (свои аналогичные такие файлы ему тоже следует добавить в .gitignore).

	В Проводнике нельзя так просто переименовать файл в .gitignore
	Будет ругаться: следует ввести имя файла
	Как обойти: надо дописать точку в конце имени, после нажатия Enter точка уберётся автоматически.
	Зачем так и почему? Хз, но лайфхак работает и всё тут.

Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или 
в коммит, то правила на него не распространяются.

	Если хочется применить .gitignore к отслеживаемым файлам, надо сделать их неотслеживаемыми.
	Вот тут есть инструкция: https://habr.com/ru/articles/709246/
	Но она чё-то как-то сложна
	Я б сделал как: временно убрал бы эти файлы из репы, закоммитил, затем вернул бы их обратно, 
		не забывв указать их в .gitignore -- вуаля!

Файл .gitignore тоже попадает во все гитовые истории (индексы, коммиты и т.д.), однако для его работы
(по игнорированию файлов/папок) не обязательно делать коммит или даже индекс, достаточно просто сохранить.

Посмотреть список игнорируемых файлов можно с помощью команды git status --ignored

ВАЖНОЕ ЗАМЕЧАНИЕ
Вообще говоря файлу .gitignore в проекте делать нечего, а можно сделать глобальный .gitignore
(и добавить туда, например, папку .idea). Прописать глобальный гитигнор можно в конфиге:
	git config --global core.excludesFile <путь>


	 = = = Шаблоны поиска и символы-джокеры в .gitignore = = =

	Если строка начинается с #, то это комментарий, и .gitignore не будет его учитывать.

	Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне 
	в .gitignore, значит файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.
			# игнорировать все файлы, которые заканчиваются на .jpeg
			*.jpeg
			# игнорировать все файлы "tmp" во всех подпапках папки docs
			docs/*/tmp 
	  Если задать правило, которое состоит только из звёздочки, Git будет игнорировать все файлы. Это происходит 
	  потому, что под звёздочку подходит любое имя файла.
	  Есть небольшое исключение касательно подпапок: звёздочка может указывать лишь на одну подпапку, т.е. если
	    задано правило docs/*/tmp, то папки вида docs/papka/tmp Гит проигнорируют, а вида docs/pap/ka/tmp нет.
	  Если хочется задать произвольное количество подпапок, то нужно использовать символ **. В таком случае при
	    записи в .gitignore строки docs/*/tmp Гит проигнорирует и папки вида docs/pap/ka/tmp тоже.
	  Тем не менее одинарная звёздочка * в .gitignore заставит Гит проигнорировать все файлы, все папки и все 
	    подпапки, т.е. только файлы в корневой папке задать звёздочкой не получится (а жаль). Просто двойные 
	    звёздочки ** работают так же, как и просто одинарная *.

	Вопросительный знак ? соответствует одному любому символу.

	Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, 
	  а только из списка, который указан в скобках.
			# игнорировать файлы file0.txt, file1.txt и file2.txt
			# при этом не игнорировать file3.txt, file4.txt, ...
			file[0-2].txt 
	В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z]).

	Если шаблон в .gitignore начинается со слеша /, то Git проигнорирует файлы или каталоги только в корневой
	  директории. А если без /, то игнорируемые файлы смотрятся не только в корневой папке, но и в подпапках.
			# игнорировать todo.txt в корне репозитория
			/todo.txt
			# для сравнения: spam.txt будет игнорироваться во всех папках
			spam.txt
	То есть по уму чтобы игнорировать файл/папку в корневой папке, надо перед именем ставить /.
	(Правда, шаблон /* по-прежнему проигнорирует все файлы во всех подпапках.)
	Если шаблон заканчивается слешем, то правило применится только к папке.
			# игнорировать папку build
			build/ 
	Обратите внимание: если build — это папка, то она будет проигнорирована. Если build — обычный файл, 
	  то он не подпадёт под правило и не будет игнорироваться.

	Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).
			# игнорировать все JPEG-файлы
			*.jpeg
			# но только не мем с Doge
			!doge.jpeg 




 = = = Мёржинг = = =

Перед слиянием желательно чтобы выдача git status была чистой!
	(т.е. нет ни modified, ни staged)
	Хотя это не обязательное условие, подробнее смотри в видеокурсе про Гит от Javascript.ru

git merge <ветка>...	Вливает изменения из <ветка> (и мб других веток) в текущую ветку.
git merge				То же самое, что git merge origin/<текущая_ветка>
							Если быть точнее, то git merge <репозиторий>/<текущая ветка>
							  Гит будет мёржить текущую ветку с её upstream-веткой; если эта ветка
							  связана с репозиторием origin, то конечно будет origin/<текущая_ветка>,
							  а репозиторий у нас как правило один и зовётся origin. 
							  Но вообше говоря так бывает не всегда.

Как запомнить, что куда:
	Указатель <ветка> никуда не сдвигается, он остаётся на месте
	HEAD вместе с указателем на текущую ветку передвигаются на мёрж-коммит (если происходит TrueMerge)
		или на тот же коммит, куда указывает <ветка> (если происходит FastForwardMerge)
	Непосредственно после мёржа HEAD^ указывает на текущую ветку, а HEAD^2 - на влитую (которую указали).
		Если вливали больше 1 ветки, то (судя по всему) HEAD^2, HEAD^2 etc будут указывать на ветки в порядке
		их перечисления в исходной команде git merge
	Для основного сценария (влив feature-ветки в main) нужно стоять на ветке main и сделать git merge <feature>
		(хотя вообще такие вещи через пулл-реквесты делаются)

Любопытный факт: если мы сначала, стоя на ветке branch1, сделаем git merge branch2, а потом переключимся
	на branch2 (git switch branch2) и сделаем уже git merge branch1, то последний мёрж будет в режиме 
	перемотки, т.к. branch2 будет родителем мёрж-коммита, а ветка branch1 указывает на мёрж-коммит,
	т.е. branch2 - прямой предок branch1, поэтому git merge branch1 будет в режиме перемотки.
Ещё один любопытный факт (не уверен в нём на 100%, но вроде так):
	По сути мёрж -- симметричная операция. Отличие только в том, какую ветку она двигает и ставит
		на мёрж-коммит, а какую оставляет на месте. Двигает она, разумеется, текущую :)
	А вот если мы переключимся на целевую ветку и будем мёржить её с предыдущей текущей, то отличие (возможно)
		будет лишь в том, что поменяются местами ours и theirs, а потом иной указатель сдвинется на мёрж-коммит,
		ну и операция ^ будет давать разный результат :)
	А в остальном вроде бы всё то же самое, но я не уверен: вдруг есть тонкие отличия? но не настолько важный 
		вопрос, чтобы копать и выяснять наверняка. Но факт любопытный :)

Существует несколько режимов слияния, в зависимости от ситуации:

  	1) Fast-forward (перемотка)

  		Происходит в случае, когда <ветка> является прямым потомком текущей
  		  ветки. Указатель текущей ветки (вместе с HEAD) просто переставляется на
  		  тот же коммит, куда указывает <ветка>
  		(Если наоборот текущая ветка является потомком <ветка>, то ничего не 
  		  происходит, выдаётся сообщение Already up to date)
  		В этом случае отдельный мёрж-коммит не создаётся

  	2) True merge (истинное слияние)
  	
  		Происходит в случае, когда <ветка> не является прямым потомком текущей ветки.
  		В результате истинного слияния создаётся мёрж-коммит (на него же после мёржа встаёт указатель HEAD),
  			а сам процесс слияния может быть разбит на этапы, т.е. может не завершиться после выполнения
  			исходной команды, потребуется ввод дополнительных команд. Это называется "прерванным слиянием".
			(О прерванном слиянии подробнее см. в главе про прерванные операции).
  			
  		В зависимости от стратегии (см. ниже) могут происходить разные сценарии, но грубо говоря
  		ищется некий общий предок, далее идёт классическое трёхсторонее слияние (3-way-merge) между версиями:
  			base 			версия общего предка
  			ours/local		версия текущей ветки
  			theirs/remote	версия вливаемой ветки
  		
  		Далее по каждой части каждого файла слияние может пойти двумя путями:
  		
  		 а) автоматическое слияние
  			Происходит, если Git сам понимает, как быть. К примеру, если файл или часть файла изменяется 
  				только в одной ветке, то Git автоматически выбирает такое единственное изменение
  			Если по всем частям какого-то фалйа прошло автоматическое слияние, то автоматическое слияние
  				прошло и по всему файлу в целом (ну.. да), затем файл добавляется в индекс.
  			Если по всем файлам прошло автоматическое слияние, то само слияние полностью прошло 
  				в автоматическом режиме. Далее просто создаётся мёрж-коммит и открывается редактор 
  				для редактирования сообщения коммита (если не было флага --no-commit; с данным флагом 
  				процесс останавливается на этом моменте).
  				
  		 б) ручное разрешение конфликта
  		 	Происходит в случае, если автоматическое слияние хотя бы одного файла не удалось.
  		 	В таком случае происходит прерывание слияния: см. главу про прерванные операции.
			Затем надо будет вручную разрешать конфликт: см. главу про конфликт слияний.

	  	Стратегии True merge:	   (для выбора стратегии надо в команду дописать "-s <имя_стратегии>")
	  	  ort			Стратегия по умолчанию в случае слияния 2 веток. 
	  					  Введена в версии 2.33 в 2021 году, до этого по умолчанию была
	  					  стратегия recursive, но стратегия ort гораздо лучше и многократно
	  					  быстрее. ORT = "Ostensibly Recursive’s Twin" = "типа близнец recursive",
	  					  типа то же, только лучше. Конструирует "виртуального" предка (см. ссылку ниже)
	  					Эта стратегия имеет кучу опций, см. их по ссылкам ниже
	  	  recursive		Стратегия в случае слияния 2 веток. 
	  					  Была стратегией по умолчанию до версии 2.33. Ищет всех общих предков
	  					  обеих ветвей и пытается из них сконструировать некого общего
	  					  "виртуального" предка, с чьей помощью и реализует классический
	  					  алгоритм трёхстороннего слияния
	  					Эта стратегия тоже имеет кучу опций, см. их по ссылкам ниже
	  	  resolve		Стратегия в случае слияния 2 веток. 
	  					  Никаких виртуальных предков, тупо ищется самый ранний предок и с ним
	  					  делает трёхстороннее слияние. Из-за этого мб приходится заново решать конфликты,
	  					  которые возможно были решены в предыдущих слияниях.
	  	  octopus		Стратегия по умолчанию в случае слияния 3 и более веток.
	  	  				  Бывают, что стратегия octopus даже не может запуститься: к примеру, как-то раз
	  	  				  я хотел смёржить 3 ветки, где в одном файле одна строка везде была разная.
	  	  				  Octopus не запустился :(
	  	  ours			Игнорирует все изменения из вливаемой ветки, по сути по отношению к текущей ветке
	  					  создаёт "пустой" коммит
	  	  subtree		Ваще не понял, что за фигня
	  	Официальная документация по стратегиям:
	  		https://git-scm.com/docs/merge-strategies
	  	Так же можно почитать хорошую статью (только она 2013 года, поэтому там нет ничего про ort):
	  		https://habr.com/ru/articles/195674/
	  	
	  	В результате True merge у получившегося коммита получается более 1 предка
	  	Посмотреть предков (parents) можно по команде git cat-file -p <hash>

	После каждого вызова merge обновляется файл ~/.git/ORIG_HEAD, в котором указан хэш
	  коммита, на котором был HEAD до слияния (или до другой опции, пишущей в ORIG_HEAD)
	  (в т.ч. даже когда было сообщение Already up to date)

Флаги для git merge:
	--no-ff			Запрет перемотки, т.е. если даже можно будет сделать мёрж перемоткой, всё равно 
						будет создан мёрж-коммит (в случае перемотки это будет в некотором смысле "пустой"
						коммит, т.е. у него отличий с его родителем не будет... вот только есть нюанс:
						родителей-то два! не будет отличий с одним из родителей, причём у меня сейчас 
						в эксперименте не было отличий со вторым родителем, т.е. с HEAD^2)   
					Можно настроить конфиг, чтобы это было по умолчанию: 
						git config [--global или др.] merge.ff false
					Также можно настроить такое поведение для конкретной ветки:
						git config branch.<branch>.mergeoptions '--no-ff'
	--ff			Отмена запрета перемотки, ежели такой будет прописан в конфиге					
	--ff-only		Разрешена только перемотка, т.е. мёрж вообще не сработает, если не получится 
						сделать перемоткой 
						
	--no-commit		Останавливает процесс мёржинга перед финальным этапом, т.е. созданием мёрж-коммита
						(тупо не работает, если мёржинг идёт перемоткой). По идее, можно постфактум 
						реализовать этот сценарий, если сохранить пустое сообщение в коммит					
	
	-m <коммент>	Можно сразу указать комментарий к мёрж-коммиту (ни на что не повляет в случае перемотки)
	--log			Дописывает в комментарий список описаний всех вливаемых коммитов из вливаемой ветки,
						не более чем 20 комментов
	--log=<n>		То же самое, но не более чем n комментов                                                         
	--no-edit		Не открывает редактор комментария, оставляет комментарий по умолчанию 
						(бесполезная фигня, в общем)                  

	
	 = = = Мёржинг в режиме сквоша -- отдельная история! = = =
	 
		git merge <ветка> --squash
		Вообще говоря, это не является мёржингом по определению, т.к. не создаётся файл .git/MERGE_HEAD, 
		  да и итоговый коммит будет обычным, т.е. иметь одного родителя.
		Сквош просто берёт все коммиты <ветки>, начиная с общего предка <ветки> и текущей ветки,
		  объединяет все их изменения и кладёт в индекс.
		При этом, разумеется, вполне могут возникнуть конфликты. Индекс в таком случае перейдёт в режим 
		  конфликта (т.е. какие-то файлы будут в слотах 1-3, а не в слоте 0).
		Поскольку сквош -- не мёржинг, то не работают команды git merge --continue и git merge --abort
		Однако прекрасно работает git reset --merge
		
		А завершать сквош нужно конечно же командой git commit
		Однако в этом случае в сообщении коммита по умолчанию будут описания и сообщения всех 
			засквошенных коммитов.
	

git merge-base <ветка1> <ветка2>	Выведет хэш общего предка двух веток (т.е. base)
git reset --hard @~					Отмена последнего успешного слияния 
										(как и последнего успешного коммита вообще)




 = = = Конфликты слияния (Merge conflicts) = = =

Конфликты слияния могут происходить во время выполнения различных команд:
	git merge, git cherry-pick, git revert, git rebase

Конфликт слияния происходит в случае, если автоматическое слияние хотя бы одного файла не удалось.

Во время конфликтов слияния происходит прерывание текущей операции (см. главу про прерванные операции).

Во время конфликта слияния изменяется выдача гитстатуса: появляется какой-то разнообразный текст про
	текущую операцию, а также появляется новый раздел Unmerged paths, в котором есть красный список
	конфликтных файлов с подписью both modified

Вообще говоря, для слияния Гит внутри себя создаёт 3 версии конфликтующего файла:
	base 			некая общая, базовая версия
	ours/local		текущая версия
	theirs/remote	"вливаемая" версия
Подробнее про то, что означают эти версии, см. в главах про соответствующие операции.

Далее Гит проходится по строкам этого файла и пытается слить их в автоматическом режиме
Как это он делает?
Гит берёт два диффа: 1) ours минус base, 2) theirs минус base.
А дальше задача становится весьма нетривиальной. Укажем только самые простые случаи:
	Если строка не изменяется в обоих диффах, то она уходит в итоговый ответ
	Если строка в одном диффе обновляется, а в другом остаётся прежней, то в итоговый ответ уходит
		обновлённая строка.
	А если строка обновляется в обоих диффах, то тут Гит ничего сделать не может и прям в файл выводит
		неразрешённый конфликт.
Примечание. В первых двух случаях слияние происходит автоматически. Если так получается сделать по 
	всем строкам файла, то слияние версий этого файла в целом происходит автоматически и конфликт
	не возникает. Так что речь в данной главе про то, когда возникают случаи третьего типа.

Как выглядит неразрешённый конфликт в файле?
В каждую неавтоматически-смёрженную часть каждого неавтоматически-смёрженного файла вписывается
	конструкция вида:
		<<<<<<< HEAD
		<версия куска из local>
		=======
		<версия того же куска из remote>
		>>>>>>> <имя ветки, указатель на коммит или что-то в этом духе>

Такие конструкции можно разрешить 
	1) руками, т.е. отредактировать так, чтобы всех этих служебных строк не было, выбрать нужные варианты,
		при желании можно дописать что-то своё и т.д. Затем нужно будет не забыть добавить файл(ы) в индекс,
		чтобы слоты 1-3 очистились, а файл попал в слот 0 (см. далее).
	2) с помощью вызова mergetool (см. ниже), при этом мёржтулы автоматически добавят файлы в индекс.

Можно также для какого-то конфликтного файла вызвать одну из этих команд (только нужно будет как и в ручном
		режиме добавить файл(ы) в индекс):
	git checkout --ours <file>		Выбрать текущую версию файла
	git checkout -2 <file>			То же самое
	git checkout --theirs <file>	Выбрать вливаемую версию файла
	git checkout -3 <file>			То же самое
	git checkout --merge <file>		Снова вернуть файл к моменту начала конфликта
										(--merge годится не только для git merge, но и для остальных)
	git checkout --conflictt=diff3 --merge <file>		
									То же самое, но в вышеописанной конструкции посередине добавится:
												||||||| base
												<версия куска из base>
										(плюс почему-то HEAD переименуется в ours, а внизу будет theirs)
		Можно сделать, чтобы в конфликтах версия общего предка показывалась по умолчанию.
		Для этого нужно в конфиге надо merge.conflictStyle сделать равным diff3


	 = = = Индекс во время конфликтов, слоты (стадии) индекса = = =
	 
	Когда происходят какие-либо конфликты, индекс начинает вести себя необычно :)
	
	У индекса вообще говоря для любого файлы используется 4 слота (стадии): от 0 до 3.
	В обычной ситуации файлы попадают только в нулевой слот, а слоты с 1 по 3 пусты.
	Но в случае конфликта наоборот: слот 0 пуст, а слоты с 1 по 3:
		1 слот -- base
		2 слот -- ours/local
		3 слот -- theirs/remote
	Посмотреть содержимое слотов можно по команде git show :<n>:<file>
	Если есть файлы в слотах 1-3, то это значит, что есть конфликты
 		(Вообще говоря, не всегда все слоты 1-3 заполнены; к примеру, если во вливаемой и текущей ветках
 		 будет независимо создан новый файл, которого не будет в base, то слот 1 будет пуст, а слоты 2-3 нет)
	
	Если сделать git add <файл>, то слоты 1-3 очистятся, а в слот 0 попадёт текущая версия файла
		(вместе с "потрохами" конфликта: "<<<<<<< HEAD" и т.д.).
		Файл в таком случае перестанет быть конфликтным и попадёт в зелёный список modified.
	(Но разумеется правильным будет перед индексацией привести конфликтующий файл в подобающий вид.) 


Как вызвать мёржтулу:
git mergetool			Вызывает стороннюю программу разрешения конфликтов (мёржтулу)
						Вызывается та программа, которая в .gitconfig записана в merge.tool (см. ниже)
						Программа будет вызываться столько раз, сколько конфликтных файлов, т.е. по разу для 
							каждого такого файла, после сохранения одного файла будет вызываться повторно и т.д.
git mergetool <файл>	Вызовет mergetool только для указанного файла
git mergetool --tool=<имя_программы>
						Вызывает стороннюю программу <имя_программы> для разрешения конфликта 


	 = = = О настройке mergetool = = =

	Чтобы работать со сторонней мёржтулой (mergetool), нужно её сперва установить, а затем настроить
	Настроить нужно две вещи: во-первых саму мёржтулу, во-вторых мёржтулу по умолчанию.
	Обе настройки прописаны в .gitconfig
		Этот файл в зависимости от ОС может находится в разных местах, у меня сейчас он находится
		непосредственно в папке C:\Users\<user>
	Чтобы выполнить каждую из этих настроек, можно вбить специальную команду, начинающуяся с:
	git config --global
	или можно вручную отредактировать файл .gitconfig

	1) Настройка самой мёржтулы
	   Нужно вбить команду
	   git config --global mergetool.<имя_мёржтулы>.path "<адрес_мёржтулы>"
	   В файле .gitconfig должно появиться следующее:
		[mergetool "<имя_мёржтулы>"]
			path = <адрес_мёржтулы>
	   (да, с кавычками здесь всё так)
	
	2) Настройка мёржтулы по умолчанию
	   Нужно вбить команду
	   git config --global merge.tool=<имя_мёржтулы>
	   В файле .gitconfig в секции [merge] поле tool должно принять значение <имя_мёржтулы>
	   т.е. должны быть две следующие строки:
		[merge]
			tool = <имя_мёржтулы>

	Примечание насчёт синтаксиса файла .gitconfig
	Сравни, в каком виде попадают в .gitcongig двухуровневые и трёхуровневые конструкции,
	  особенно что происходит со средним полем в трёхуровневой конструкции, весьма забавно :)

	Просмотреть список доступных мёржтул можно по команде:
	git mergetool --tool-help
	(правда, почему-то у меня не отображаются установленные мной мёржтулы... возможно, я не 
	 совсем верно сделал записи в .gitconfig... ну и хрен с ним, главное всё работает)


	 = = = О функционале мёржтул = = =

	В процессе разрешения конфликта создаётся 4 файла с разными пометками:
	BACKUP 	-- видимо, просто копия изначального файла
	BASE 	---\
	LOCAL 	------ ну тут всё понятно, см. выше
	REMOTE 	---/

	В мёржтулах бывает 2 или 3 исходных окна (это локал с ремоутом, опционально бейз) плюс
	  окно с итоговым результатом
	В мёржтулах по сути нужно только выбирать варианты, иногда какой-то свой код писать.
	По сути больше ничего и не надо.

	ВНИМАНИЕ!
	После завершения работы мёржтулы Гит почему-то оставляет файл с названием
	<имя_бывшего_конфликтящего_файла> + ".orig"
	в котором (вроде как) сохраняется изначальный "гибридный" конфликтный файл 
	(т.е. со всякими этими служебными строками типа <<<<<<< HEAD ).
	После удачного разрешения конфликта НУЖНО ОБЯЗАТЕЛЬНО УДАЛИТЬ ЭТОТ ФАЙЛ!!!	
	
	upd. Можно отключить это следующей настройкой:
		git config --global mergetool.keepBackup false
	Подробнее об этом почитать тут:
	https://stackoverflow.com/questions/1251681/git-mergetool-generates-unwanted-orig-files


	 = = = ВАЖНО: об отличии команды git merge и самого слова merge = = =
	
	Сразу скажу: не совсем уверен во всём, что я тут написал, слишком сложно искать информацию по данной теме.
	Поэтому за точность не ручаюсь, но вроде бы всё примерно так.
	
	Сами слияния (merge) происходят не только при выполнении команды git merge, но также и при выполнении команд
		git cherry-pick, git revert, git rebase (и возможно каких-то других).
	При этом Git пишет "Merge conflict", "Auto-merging" и т.д. по отношению к каждому слиянию.
	То же самое он выдаёт и во время выполнения команды git merge.
	
	Так вот, следует понимать, что если Гит, скажем, во время выполнения команды git rebase пишет 
		о merge conflict, это НЕ значит, что тут будет применяться полностью все действия команды git merge.
	Тут речь непосредственно о слиянии.
	
	Что нужно для создания попытки слияния, разрешения merge conflict etc?
		Нужно (Гиту) сперва взять три версии конфликтного файла: base, ours и theirs
		Нужно (опять же Гиту) попробовать слить версии в автоматическом режиме
		Если не вышло, то случается конфликт слияния
		В самом файле появляются всякие >>>>>>> и <<<<<<<
		Далее тут везде можно (юзеру) открывать mergetool или ручками делать
		Кстати, base вовсе не обязан быть предком local и remote. К примеру, при выполнении git cherry-pick
			base является родителем remote (а remote -- это та версия файла, которая соответсвует коммиту, 
			указываемому в команде cherry-pick), а вот local где-то в стороне болтается (он типа версия от HEAD). 
			А при git revert вообще всё ещё более странно: это же cherry-pick наоборот, поэтому base -- версия
			из того коммита, который ревёртим, а remote -- его родитель! Всё с ног на голову просто! Но всё
			при этом вполне логично :)
	
	Какие сущности из git merge НЕ используются при merge conflict?
		Не используется дилемма FastForwardMerge и TrueMerge
		Стратегии мёржа типа ort, recursive etc тоже здесь не применяются
		Тут нет никакого дела до того, какие ветки мы сливаем, какие там есть предыдущие конфликты: на данном 
			этапе есть только 3 версии файла и попытки слепить из них что-то одно.
		Ну и при выполнении git merge версия base будет общим предком local и remote (возможно, виртуальным)
	
	Подводя итог: 
		бывают "мелкие", "локальные" слияния, которые могут возникнуть в самых разных ситуациях
		но также есть "глобальная" команда git merge, выполнение которой может состоять из нескольких таких
			"локальных" слияний
		но эти "локальные" слияния возникают и в процессе выполнения иных гитовых команд (cherry-pick, revert, 
			rebase, stash etc)




 = = = Прерванный режим = = =
(термин сам подобрал, я хз как официально называется, лень искать)

Бывает у следующих команд: git merge, git cherry-pick, git revert, git rebase (мб ещё у каких-то, не выяснял).
Также может случиться у git pull, но это считается как git merge (т.к. git pull = git fetch + git merge).

Может случиться из-за:
	1) наличия конфликта слияния, который не может быть разрешён в автоматическом режиме;
	2) указания флага --no-commit (или что тоже самое: -n);
	3) сохранения пустого сообщения мёрж-коммита.

Во время прерванного режима в Git Bash в конце строки приглашения вместо "(<текущая ветка>)" пишется:
		"(<текущая ветка> | [MERGING или CHERRY-PICKING или REVERTING или REBASE])",
	что и сообщает нам о том, что возник конфликт слияния и операция прервана.
	Плюс к этому если операция проходит в несколько этапов, то после её названия через слеш указываются
		текущий номер этапа и общее их количество.

Также во время прерванного режима в директории ~/.git/ создаётся файл с названием MERGE_HEAD, CHERRY_PICK_HEAD,
	REVERT_HEAD или REBASE_HEAD, который содержит хэш какого там коммита (лень разбираться какого именно).
	Ну там в MERGE_HEAD например хэш вершины вливаемой ветки, ну в остальных что-то похожее.
	Короче, по наличию такого файла Гит и определяет, есть ли сейчас какая-нибудь прерванная операция (ну вроде)

Также изменяется выдача git status.
	Если конфликтов нет, то появляется надпись "All conflicts fixed", а дальше что-то про merge/revert/etc
	Если есть конфликты, то появляется какой-то разнообразный текст про текущую операцию, а также появляется новый 
		раздел Unmerged paths, в котором есть красный список конфликтных файлов both modified

Для управлением ходом прерванной операции существуют следующие флаги (употребляются так: git <операция> <флаг>):
	--continue	Попытаться возобновить и продолжить операцию
				Обычно это делают после попыток разрешения конфликтов (вручную или с помощью mergetool)
				Если все конфликты разрешены, то --continue завершает операцию созданием коммита 
					и вызовом текстового редактора для написания сообщения коммита; в таком случае по сути
					(и вроде как по факту) это псевдоним для git commit
	--skip		Пропускает текущий конфликт слияния, оставляет файл со всякими <<<<<<<
					Не работает с git merge
	--quit		Полностью останавливает выполнение команды, репозиторий остаётся в том состоянии,
					которое было на момент выполнения git cherry-pick --qiut
	--abort		Отменяет выполнение всей прерванной операции
				Возвращает репозиторий к состоянию до её вызова
				Работает только если операция ещё не завершена. Отменить состоявшуюся операцию 
					этой командой не выйдет.
				Для git merge существует также синонимичная команда:
					git reset --merge
				По сути, --abort работает почти как git reset --hard, вот только
					в отличие от последней не трогает индекс, который был до начала операции. 
					(Если изначально индекс был чист, то --abort действуют в точности,
						как git reset --hard)

Для интерактивного ребейза также существуют два дополнительных флага --edit-todo и --show-current-patch,
	но о них в соответствующей главе.




 = = = Черри-пикинг и ревёртинг = = =

git cherry-pick <commit_hash>...
	Берёт изменения, которые были сделаны в указанном(-ых) коммите(-ах) и накладывает на текущую ветку. 
	Эта команда копирует имя и дату автора коммита (но не копирует имя и дату коммиттера)
	После завершения работы команды открывается сторонний редактор для редактирования сообщения коммита,
		там по умолчанию вписано сообщение указанного коммита <commit_hash>

При cherry-pick могут образоваться конфликты слияния, выполнение команды тогда прервётся.
При этом, что характерно, версии файлов будут немного необычные:
	ours/local -- это, как и полагается, текущая версия файла (т.е. из HEAD)
	theirs/remote -- это версия файла из того коммита, которым делается cherry-pick
	base -- это версия из родителя того коммита, которым делается cherry-pick
То есть base не является предком local! По сравнению с git merge это весьма необычно :)

Флаги:
	--no-commit		Сделает черри-пик, но остановится перед стадией создания коммита,
						даст шанс переделать коммит и/или его сообщение
	-n				То же самое
	-x				добавляет в описание информацию о том, откуда коммит был скопирован


git revert <commit hash>...
	Инвертирует изменения, которые были сделаны в указанном(-ых) коммите(-ах), и накладывает на текущую ветку. 
	Можно сказать это как git cherry-pick, только наоборот 
		(Наверное есть некоторые отличия, но пока не хочу в них вдаваться. Хотя в git команды revert и
			cherry-pick настолько тесно связаны, что фактически реализованы в одном файле: revert.c.)
	После завершения работы команды откравается сторонний редактор для редактирования сообщения коммита,
		там по умолчанию написано следующее: 
					Revert "<коммент того коммита>"
		Кстати, если сделать реверт на реверт, то коммент по умолчанию будет: 
					Reapply "<коммент того коммита>"

При revert могут образоваться конфликты слияния (выполнение команды тогда прервётся).
При этом, что характерно, версии файлов будут ещё более необычные, чем при cherry-pick:
	ours/local -- это, как и полагается, текущая версия файла (т.е. из HEAD)
	base -- это версия файла из того коммита, которым делается revert
	theirs/remote -- это версия из родителя того коммита, которым делается revert
То есть base не является ни предком local, ни даже предком remote! Он наоборот потомок remote!
По сравнению с git merge это вообще с ног на голову!
Однако в сравнении с git cherry-pick это просто наоборот: поменяли местами base и remote, делов-то!

Флаги:
	--no-commit		Сделает ревёрт, но остановится перед стадией создания коммита,
						даст шанс переделать коммит и/или его сообщение
	-n				То же самое


Флаги прерванного режима cherry-pick и revert: см. выше в соответствующей главе.

Офигенная статья про подноготную cherry-pick и revert (и заодно в общем про 3-way-merge):
https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/
(на английском, но автоперевод хорош!)




 = = = Пуллинг = = =

(не доизучено, доизучать!)

git fetch	подтягивает (обновляет) все ветки слежения с удалённого репозитория,
			  при этом не двигает ни одну из локальных веток

git pull	связка команд git fetch и git merge 
				(последнее, если что, то же самое, что и origin/<текущая_ветка>)
			Другими словами:
			  делает git fetch, т.е. тянет все ветки слежения, плюс текущую ветку
			 	тянет за соответствующей веткой слежения, HEAD тянет за ней.
			  	Остальные локальные ветки не трогает 
						(кажется я тут лишнего понаписал, доразбирать!)
			  затем делает git merge origin/<текущая_ветка> со всеми вытекающими
				последствиями мёржа:
				  1) Если получается fast forward merge, то текущая ветка подтягивается
					 за соответсвующей веткой слежения, HEAD тянется за ней,
					 с остальными ветками ничего не происходит.
				  2) Если получается true merge, то конфликт пытается разрешиться
					 в автоматическом режиме; если не выходит, то операция прерывается,
					 можно запускать мёржтулу, решать конфликт и т.д. При этом 
					 в строке приглашения Git Bash пишется MERGING. По окончании
					 слияния создаётся мёрж-коммит. (Хотя так наверное лучше не 
					 делать, мёрж-коммит из ветки и её ветки слежения -- ну, такое себе...)
					 С остальными ветками по прежнему ничего не происходит.

git fetch origin <branchname>:<branchname>
		(Не уверен на 100%, что делает именно это, но кажется делает именно это)
		Тянет только ветку слежения <branchname> и соответствующую ей локальную
		  ветку, при этом без перехода текущей ветки и HEAD на <branchname>. 
		  Текущая ветка остаётся на своём месте, HEAD тоже остаётся на месте.
		  И все остальные ветки (локальные и слежения) тоже не меняются
		Но в отличие от git pull мёрж случится только Fast-Forward, т.е. если 
		  <branchname> будет прямым предком origin/<branchname>. Мёрж не случится
		  даже в случае отсутствия конфликта изменений (т.е. в таком случае 
		  git pull сделает мёрж в автоматическом режиме и создаст мёрж-коммит, а вот
		  git fetch origin <branchname>:<branchname> направит origin/<branchname>
		  и <branchname> по разным веткам).
		(Видимо, мёрж просто делается с ключом --ff-only)

Т.е. git pull тянет локальную текущую ветку, а ветки слежения тянет все.
Но git fetch origin <branchname>:<branchname> тянет указанную локальную ветку,
	а ветки слежения (остальные) не тянет вообще
	Какая-то странная логика по части именования данных команд

git fetch origin +<branchname>:<branchname>
		Делает то же, что и без плюса, однако в случае расхождений просто тянет
		  локальную ветку вслед за веткой слежения, тем самым выкидывает из 
		  истории локальные коммиты, которых не было на удалённом репозитории
			(не факт, что работает именно так)

git fetch origin <branchname>:<branchname> не совсем адекватно работает в том случае, если 
	указанная ветка есть только на серваке, а с локалки удалилась. Данная команда создаст
	такую ветку на локалке в том же месте, где и сервачная ветка слежения, однако почему-то
	не свяжет их между собой, т.е. не настроит локальной ветке upstream (это можно проверить
	по команде git branch -vv).

Для несуществующей локальной ветки сработает следующая команда:
	git branch <ветка> origin/<ветка>
Однако она не сработает для существующей. Но есть команда для обоих случаев:
	git branch -f <ветка> origin/<ветка>
Но и у неё есть свои недостатки: не сработает, если <ветка> -- текущая.
Совсем универсальная команда такова:
	git switch -C <ветка> origin/<ветка>




 = = = Ребейзинг = = =

git rebase <branch>	 	ребейзинг текущей ветки на целевую <branch>
git rebase main			классический случай подобновления текущей ветки от main'а

Это значит, что коммиты текущей ветки подобновляются с учётом новых коммитов целевой ветки.
Сами коммиты целевой ветки не меняются (напротив, это _они_ меняют коммиты текущей ветки).

Что означает предлог "на"? Вся текущая ветка как бы отцепляется от дерева коммитов и переносится
	(т.е. перебазируется -- происходит rebase) на целевую, то есть ставится своим началом в конец оной.
Хорошо иллюстрируют данную ситуацию картинки в видео:
	https://rutube.ru/video/685378178392cdf2e6502df61e6bf36f/?playlist=453217

Что происходит, если целевая ветка является прямым потомком текущей?
	Тут типа то же самое, что и с мёржем -- режим перемотки. Только термина такого тут нет, Гит напишет:
		Successfully rebased and updated refs/heads/reb_com_2.			(и всё, больше ничего)
	Но суть та же, что и у мёржа в режиме перемотки: HEAD вместе с указателем на текущую ветку 
		переставляются на вершину целевой ветки.
	Почему так получается? Потому что общий предок целевой и текущей ветки -- вершина текущей ветки,
		поэтому у текущей ветки надо переставить 0 (ноль) коммитов. Ребейз только делает самое первое
		и самое последнее действие: переставляет HEAD на вершину целевой ветки, а затем сразу указатель
		текущей ветки переставляет на HEAD. Всё. (Алгоритм см. ниже)

Как происходит ребейзинг?
	Сперва переставляется HEAD на вершину целевой ветки. Внимание: HEAD указывает не на указатель
		ветки, а именно на вершину, т.е. на тот же самый коммит, куда и указывает ветка. Да, получается
		состояние оторванной головы. Это специально делается для того, чтобы указатель целевой ветки
		не полз вслед за HEAD, который должен будет перемещаться в процессе ребейза.
	Ищется общий предок обеих ветвей. 
	Берутся все коммиты текущей ветки, являющиеся потомками этого общего коммита, пусть их N (сам общий
		предок не включается в набор). С этим набором коммитов и будет происходить работа.
	Алгоритм идёт последовательно по каждому коммиту из этого набора, начиная от самого старого коммита.
	На каждом шаге делается черри-пик "итерируемого" коммита на целевую ветку (т.е. если бы мы сами
		делали черри-пик, нужно было бы вставать на целевую ветку), результат прицепляется к вершине
		целевой ветки. Туда же передвигается HEAD.
		Если образуется конфликт слияния, то алгоритм пытается его решить в автоматическом режиме.
		Если не получается, то алгоритм останавливается и ждёт от пользователя разрешения конфликта.
		После завершения разрешения конфликта создаётся коммит, сообщение его копируется с исходного
		(или же алгоритм предлагает отредактировать, если изначально такое было сказано: см. ниже).
	Если так получается, что в результате черри-пикинга случается пустой коммит по отношению
		к предыдущему шагу алгоритма (вполне может случиться, что изменение этого коммита было полностью
		продублировано в целевой ветке), то такой коммит не записывается и пропускается.
	После завершения последней итерации алгоритм берёт указатель текущей ветки и переставляет туда же,
		где стоит HEAD, а сам HEAD ставит на этот переставленный указатель.

После завершения алгоритма коммиты бывшей текущей ветки становятся висящими (если на них не указывали 
	какие-либо иные ветки, конечно же).

Работают флаги прерванного режима (см. соответствующую главу). Помимо них, работают:
git rebase --edit-todo				Посмотреть/отредактировать список интерактивного ребейзинга (см. ниже)
git rebase --show-current-patch		Показывает патч ребейза на текущем шаге

ВНИМАНИЕ! В случае выполнения иных подобных многоступенчатых алгоритмов для полной отмены алгоритма
  работает команда git reset --hard, но здесь эта команда НЕ РАБОТАЕТ! Только через --abort! Всё дело
  в том, что в процессе ребейза HEAD гуляет (и вообще говоря происходит отрыв башки). Поэтому после
  хардресета HEAD останется там, где был в процессе ребейза, а не до начала ребейза.
	
Как отменить ребейз после завершения алгоритма?
	Нужно сделать git reset --hard на бывшую вершину бывшей текущей ветки
	Её можно найти по имени ORIG_HEAD, однако если в процессе ребейзинга были какие-нибудь ресеты или 
		был ребейз смёрженных веток (и может в ещё каких-то жопских случаях), то ORIG_HEAD может указывать
		куда-то в другое место
	В таком случае стоит глянуть git reflog <текущая_ветка>, скорее всего там на предпоследнем месте и будет
		нужный нам хэш, можно даже сразу вызвать git reset --hard <текущая_ветка>@{1}
ВНИМАНИЕ! Поскольку в процессе ребейза HEAD много раз переставляется, поэтому по итогу в рефлог может быть
	внесено	довольно много записей. Поэтому после завершённого ребейза вернуться в исходную точку с помощью
	команды git reset --hard HEAD@{1} вряд ли получится (разве что только в совсем уж простых случаях).

В частности, если нам просто нужно в текущей ветке поправить один или несколько коммитов, то нужно в команде
		git rebase <hash> -i						(про флаг -i см. далее)
	указать хэш РОДИТЕЛЯ самого раннего коммита. При этом если на этом пути были какие-либо ответвления, то
	они конечно сохранятся там, где были, вот только исходная наша ветка перейдёт на совсем новые коммиты. Вот так!
Удобно ещё в данном случае указать вот так:
		git rebase HEAD~<n> -i
	где n -- это количество последних коммитов, подлежащих редактированию. Или, если надо отредачить один
	коммит, n -- это номер этого коммита с конца (включая вершину ветки, т.е. она -- это номер один).
	
Разновидности команды rebase:
	git rebase <ветка1> <ветка2>
			Делает ребейз <ветки2> на <ветку1>, переставляет HEAD на <ветку2> (причём <ветка2> становится 
				активной сразу же, последующий ребейзнг идёт с указанием <ветки2> как текущей)
	git rebase --onto <ветка1> <ветка2>	
			Делает ребейз (текущей ветки минус <ветка2>) на <ветку1>, т.е. ребейзит все коммиты текущей
				ветки, являющиеся потомками <ветки2> (при этом коммит-вершина <ветки2> игнорируется)
	git rebase --onto <ветка1> <ветка2> <ветка3>
			Делает ребейз (<ветки3> минус <ветка2>) на <ветку1>, т.е. ребейзит все коммиты <ветки3>,
				являющиеся потомками <ветки2> (при этом коммит-вершина <ветки2> игнорируется).	

Вместо веток в принципе можно указывать любые указатели на коммиты, в т.ч. хэши,
	в т.ч. хэши висящих коммитов (проверено!)


Интерактивный ребейз - флаги: -i или --interactive 	
	
	Список действий интерактивного ребейза:
		p	использовать коммит как есть
		r	переписать ему коммент
		e	полностью поправить коммит
		s	сделать squash с предыдущим коммитом (не может быть в первой строке!)
		f	то же самое, но коммент засквошенного коммита не уйдёт в коммент итогового
		x <command>
			можно добавить произвольную команду терминала в этот список, выполнит
		b	остановиться на этом моменте (без указания коммита)
		d	пропустить коммит
			(там есть ещё действия, но в моём видеоучебнике их не было, они позднее появились)
	Все действия можно переставлять местами как угодно, можно также удалять
	Однако можно запретить удаление строки с действием (чтобы не пропустить по ошибке):
		git config rebase.missingCommitsCheck warn 		(или можно error вместо warn)
	Тогда пропускать коммит удалением строки не выйдет, тут как раз пригодится действие d
	
	Можно в списке действий сделать по умолчанию, чтобы действие одной буквой писалось:
		git config rebase.abbreviateCommands true
		


Пара комментов с Хабра: https://habr.com/ru/articles/201922/
	Главное в туториалах по rebase — не делайте этого с комитами, доступными не только вам.
	То же касается и amend и вообще любых правок репозитория после того как сделан git push. 
 	 Кстати, об этом неплохо-бы написать в статье, пусть даже многие сервера и не принимают такие правки.
	А ещё не делать git pull --rebase или git rebase после мержа веток.

Коммент от Лёши:
	если при ребейзе возник конфликт где-то в середине, то он почти до конца теперь 
		будет возникать на каждом коммите
	поэтому ребейзить лучше маленькие ветки в которых мало коммитов

Что касается ребейза после мёржа веток: вот в этом видео разбирается данный случай:
	https://rutube.ru/video/53bb589f5504888b1c09395530b4b25d/
	Не скажу, что хорошо понял данное видео
	Здесь напишу лишь что они там ещё для таких ситуаций рассматривают флаг --rebase-merged
	Крч, какое-то лютое задротство...


Ещё о плюсах/минусах ребейза по сравнению с мёржем:
	+ История получается более красивая
	- Можно делать только в индивидуальных ветках
	- Есть шанс сделать много битых коммитов (из-за семантических конфликтов), 
		в то время как у мёржа такой максимум один может случиться

От битых коммитов может помочь запуск автотестирования после каждого этапа ребейзинга
К счастью, Git позволяет такое устроить с помощью команды rebase.
Нужно указать следующий флаг:
	-x '<команда>'
где <команда> -- команда терминала
	Кажется, Git даже понимает, когда эта команда завершается нормально, а когда с ошибкой, во втором случае
	Git тормозит процесс ребейзинга. Что и как он понимает -- лично я пока не понимаю, да и автор видео 
	не поясняет. Видимо потом пойду. Кстати, ссылка на видео:
	https://rutube.ru/video/befae524504762da895fb64c1ff99dd4/




 = = = git stash = = =

Прекрасная статья, в которой многое нужное написано довольно подробно и понятно:
https://skillbox.ru/media/code/lokalnoe-khranilishche-git-kak-rabotat-s-git-stash/

Стеши имеют название stash@{<n>}
Это типа стек: первый зашёл -- последний вышел

git stash push				Закинуть текущие изменения в стеш
								Они пойдут в stash@{0}. А стеши, которые были до, увеличат свой номер на 1
								Сообщение стеша будет по умолчанию: хэш и описание текущего коммита
git stash					То же самое
git stash save				Почти то же самое
	Примечание насчёт git stash save и git stash push.
   	  Это по сути одинаковые команды. savе более старая и сейчас неактуальна, push вместо неё
   	  У push чуть больше опций. Однако у save проще писать коммент к сейву (без -m)
   	  git stash -- это вроде как полный синоним git stash push
git stash save "<msg>"		Закинуть текущие изменения в стеш, указать сообщение этому стешу
git stash push -m "<msg>"	То же самое
	Флаги для push/save:
		--include-untracked, -u		Включить в стеш неотслеживаемые файлы
		--all, -a					Включить в стеш неотслеживаемые и игнорируемые файлы
		--patch, -p					Включить интерактивный режим частичного добавления
										(аналог git add -p, подробнее см. по ссылке выше)
		--keep-index, -k			В стеш идут только незаиндексированные изменения
		--staged, -S				В стеш идёт только то, что в индексе, незаиндексированное остаётся
										(если не случится конфликтов)
										ВНИМАНИЕ! Вообще аккуратно надо использовать эту функцию, может
											произойти что-то странное (но вроде ничего фатального)

git stash list				Показывает текущий список стешей
git stash show				Показывает, в каких файлах и в каких масштабах изменения в последнем стеше
git stash show <stash>		То же самое в указанном стеше
git stash show -p			Показывает сами изменения (как в git diff; можно и <stash> тоже указывать)

git stash pop				Достаёт последний стеш, удаляя его из списка стешей
								При этом очищает весь индекс (т.е. все изменения уходят в неиндексированные)
								(См. ниже в git stash branch причину, почему так сделали)
git stash pop --index		То же самое, но при этом сохраняет индекс
git stash pop <stash>		Достаёт указанный стеш, удаляя из списка стешей, очищая индекс
								(но конечно можно взять флаг --index и сохранить индекс)
git stash apply				Работает как git stash pop, только не удаляет текущий стеш
								Работают также --index и <stash>

git stash branch <branch>	Создаёт новую ветку, переключается на неё и достаёт последнее состояние из стеша
								При этом ветка создаётся на том коммите, с которого был сделан стеш
								Можно указать <stash> (после названия ветки)
								А вот --index не работает... так как он уже по умолчанию применён!
									Почему здесь так, а в git stash pop не так?
									Потому что создавая новую ветку из того самого места, где был
									сделан стеш, мы гарантировано не получим конфликты. А вот git stash pop
									может применяться где угодно, значит могут быть конфликты, а они как раз
									в индекс пишутся. И вот чтобы не мешать этим возможных конфликтам, и было
									придумано очищение индекса.
								Если указать существующую ветку, выдаст ошибку

git stash drop				Удаляет последний стеш из списка стешей
								Можно указать <stash>
git stash clear				Полностью очищает текущий список стешей


	 = = = Конфликты при стешинге = = =
	
	При стешинге порой случаются конфликты, причём порой непонятно почему (из-за \n, например)
	В таком случае в конфликтный файл записывается следующее:
	
		<<<<<<< Updated upstream
		[вариант из того, к чему применяется стеш]
		=======
		[вариант из стеша]
		>>>>>>> Stashed changes
	
	В гитстатусе про файл, подвергшийся такому изменению, пишут both modified
	А вот из git stash list кажется данный стеш не уходит... странно кстати




 = = = Сравнение версий = = =

git diff			Показывает отличия текущей версии репозитория от последней заиндексированной
					(или от последнего коммита, если индекс пуст)
					Если отличий нет (т.е. нет незаиндексированных изменений), то ничего не выводит
git diff --staged	Сравнивает индекс с последним коммитом
					Если индекс пуст, то ничего не выводит
git diff --cashed	То же самое
git diff HEAD		Сравнивает текущее состояние репозитория с последним коммитом


	 = = = О работе git diff = = =

	Если индекс пуст и нет изменений, то git diff, git diff --stages и git diff HEAD пусты
	Если индекс пуст, но есть изменения, то git diff не пуст, а git diff --stages пуст
	Если индекс не пуст, но нет неиндексированных изменений, 
		то git diff пуст, а git diff --stages не пуст
	Наконец, если индекс не пуст, но есть ещё незаиндексированные изменения,
		то git diff не пуст и git diff --stages не пуст
	Во всех трёх последних случаях git diff HEAD не пуст
	
	ДРУГИМИ СЛОВАМИ
	Есть 3 состояние: текущее, индекс, коммит.
	git diff 			это текущее минус индекс
	git diff --stages 	это индекс минус коммит
	git diff HEAD		это текущее минус коммит


git diff <hash_a> <hash_b>		Сравнивает коммиты <hash_a> и <hash_b>
git diff <branch_a> <branch_b>	Сравнивает ветки <branch_a> и <branch_b>
		Можно также сравнивать ветку и коммит (неважно, т.к. ветка - это же указазатель на коммит)
git diff HEAD~ HEAD 	Сравнивает предпоследний коммит с последним

git diff <file>...		Сработает как git diff, только для указанных файлов
						(Думаю, все остальные разновидности git diff'а тоже тут сканают)

git diff <commit1>:<file1> <commit2>:<file2>		Сравнит два файла в двух разных коммитах

Флаг --name-only покажет только названия отличающихся файлов, внутренности не покажет
Флаг --U<n> настроит количество обрамляющих неизменённых строк (по умолчанию n=3)

	ЗАМЕЧАНИЕ
	git diff игнорирует новые неотслеживаемые файлы




 = = = Про git config = = = 

Есть 3 флага у git config:
  --system (системный) - на уровне системы
		Файл конфига: %PROGRAMFILES%\Git\etc\gitconfig (без точки, да!)		
					(например, D:\Program Files\Git\etc\gitconfig)
  --global (глобальный) - на уровне пользователя
		Файл конфига: %HOMEPATH%\.gitconfig			(например, C:\Users\I\.gitconfig
  --local (локальный) - на уровне проекта; этот флаг по умолчанию, т.е. его можно не ставить
		Файл конфига: <project>\.git\config

Гит сначала ищет параметр в локале, если не находит - идёт в global, не находит там - идёт в system

git config --list	Вывести список всех конфигураций во всех файлах
			Можно добавить флаг из списка выше, чтобы показать только системные, глобальные 
				или локальные конфигурации

git config --unset <param>							Удалить параметр
git config --remove-section <section>				Удалить полностью секцию ("папку") параметров
git comfig <--global/etc> alias.<имя> "<значение>"	Задаёт пользовательские команды


	 = = = О синтаксисе файла .gitconfig = = =

	Рассмотрим два примера.
	
	Если, например, вбить команду
			git config --global merge.tool=<имя_мёржтулы>
		то в файле .gitconfig в секции [merge] поле tool примет значение <имя_мёржтулы>
		т.е. появятся две следующие строки:
	
			[merge]
				tool = <имя_мёржтулы>

	А если вбить команду
			git config --global mergetool.<имя_мёржтулы>.path "<адрес_мёржтулы>"
		то в файле .gitconfig появятся вот эти две строки:
	
			[mergetool "<имя_мёржтулы>"]
				path = <адрес_мёржтулы>

	Сравни, в каком виде попадают в .gitcongig двухуровневые и трёхуровневые конструкции,
		особенно что происходит со средним полем в трёхуровневой конструкции, весьма забавно :)




 = = = Информационные команды: = = =

git --version		Проверить текущую версию Git'а
git remote -v		Проверить текущие url'ы репозиториев
git status			Проверка текущего статуса: 
								в какой ветке сейчас локальный репозиторий
								какие файлы (не) заиндексированы (=(не) подготовлены к коммиту)
								какие файлы (не) закоммичены
git status --ignored		То же самое, только добавится новый раздел с игнорируемыми файлами

git show <хэш>				Показывает информацию о коммите и список всех его диффов 
								(без указания коммита - текущий коммит)								
	ключ --pretty=fuller	Показывает и автора, и коммиттера, и обе даты (автора и коммиттера)
git show <хэш> <файл>		Показывает дифф указанного файла в указанном коммите
git show <файл>				Покажет дифф указанного файла в текущем коммите

git show <хэш>:<файл>		Покажет версию файла на момент указанного коммита
git show :<файл>			Покажет текущую версию указанного файла

git show :<n>:<файл>		Покажет содержимое слотов индекса по указанному файлу, где n - номер слота
								(напомню, слот 0 -- для обычного индекса, от 1 до 3 -- для конфликтного)

git cat-file <ключ> <объект>	Показывает информация о объекте по ключу:
				-t				Тип объекта (например, commit или tree)
				-s				Размер объекта (в байтах, видимо)
				-p				Разная прикольная инфа (дерево, родитель, автор, коммитер...)
				
git rev-parse <commit>			Показывает полный хэш данного коммита


	 = = = Логи = = =

	git log				Показывает все коммиты текущей ветки
	 ключи:	--all		Показывает все коммиты вообще
			--graph		Не просто перечисляет коммиты, но отрисовывает вложенную структуру
			--oneline	Кратко по каждому коммиту, только в одну строку (кусок хэша и коммент)
							(имеет смысл сразу все 3 штуки делать)
			--first-parent		Показывает только первых родителей (т.е. проигнорирует влитые ветки)
			--pretty=fuller		Показывает и автора, и коммиттера, и обе даты (автора и коммиттера)
	git log -<N>		Показать последние N коммитов текущей ветки
	git log <ветка>... 	Показать историю указанной ветки (можно указать несколько веток)
	git log -p			Показать историю со всеми диффами коммитов
	git log <file>		Показать историю коммитов, в которых менялись указанные файлы
	  Вообще можно очень нехило кастомизировать выдачу git log'а. См. подробнее тут:
		https://rutube.ru/video/47e7f7ad0528ed5568c0dae433fdb588/
	
	git reflog				Показать журнал изменений в заголовке локального репозитория. 
							Отличный вариант для поиска утраченных данных.
	 						  (Кстати, git reflog = git log --oneline -g)
	git reflog -<N>			Последние N записей рефлога
	git reflog <ветка>		Журнал изменений для указанной ветки
	git reflog --date=iso 	Выведет рефлог с указанием дат
		ВНИМАНИЕ!
		1) Записи в рефлоге гарантировано хранятся 90 дней, а для недостижимых коммитов -- 30 дней!
		   За это в конфиге отвечают поля gc.reflogExpire и gc.reflogExripeUnreachable соотв.
		   Можно им указать never и тогда всё будет ок.
		   Рефлог (и проч.) чистится при вызове некоторых команд (типа пуш, пулл... но не факт,
				у меня почему-то не сработало). Также есть специальная команда git gc, которая
				согласно названию занимается сборкой мусора. 
		2) Рефлоги не пушатся! Они только на локалке остаются!
	git reflog expire --expire=<date/time>		Очистить рефлог до указанного момента времени
								ключ --all		очистит все рефлоги
			Подробнее про это: 
			https://rutube.ru/video/a5c74d5b958d271310bfb8cf4c6fdba5/?playlist=453218&playlistPage=1
	
	git fsck --unreachable		Выводит список висящих коммитов


git merge-base <ветка1> <ветка2>	Выведет хэш общего предка двух веток
git blame <file>	Просмотреть, кто, что и когда изменил в <file>
							(инфа по каждой строке файла)

gitk			Запуск гуя. Покажет текущую ветку (вроде как, но это не точно)
gitk --all		Гуй покажет все ветки, построит строковое графическое дерево

git help				Подсказка гита
git <команда> -h		Откроет простую подсказку по команде в терминале
git <команда> --help	Открывает в браузере интернет-страничку с подробнейшей информацией по
							данной команде
git help <команда>		То же самое




 = = = git bisect = = =

Интересная команда из продвинутых
Если выяснилось, что на данном коммите код не работает, а сколько-то коммитов назад он работал,
	то нужно как-то искать коммит, на котором код сломался
В этом поможет интерактивный инструмент git bisect, который осуществляет удобный бинарный поиск битого коммита.

Вот хороший подробный гайд про это:
https://habr.com/ru/articles/591447/
Не вижу смысла сейчас копать глубже :)




 = = = Если вывод не помещается на страницу (например, от git log): = = =

Git хочет показать вам более одного экрана с информацией, для этого он вызывает стандартную
программу пейджера Unix less. Просто введите q, чтобы вернуться в терминал, когда вы больше не
хотите перемещаться по выходным данным.

q вернуться в терминал
j перейти на одну строку вниз
k переместиться на одну строку вверх
space перейти на одну страницу вниз
b перейти на одну страницу вверх
h показать помощь
/ поиск вперёд
? поиск назад
n перейти к следующему результату поиска
	shift+n к предыдущему

Внимание! Должна быть включена английская раскладка, с русской не работает!