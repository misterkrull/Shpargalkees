Хорошие статьи:
https://habr.com/ru/articles/174467/
https://habr.com/ru/companies/skillbox/articles/442260/
https://habr.com/ru/companies/yandex_praktikum/articles/768492/
https://habr.com/ru/companies/yandex_praktikum/articles/728302/
https://selectel.ru/blog/tutorials/git-fetch-command-how-is-it-different-from-git-pull/
https://habr.com/ru/articles/150001/
https://old.calculate-linux.org/main/ru/git




 = = = Начало работы с Git, с репозиторием = = =

Для начала работы с Git нужно создать репозиторий. Это можно сделать двумя способами:
 1) превратить какую-либо директорию на компьютере в репозиторий
 2) склонировать удалённый репозиторий на свой копмьютер

	Чем папка (директория) отличается от репозитория? 
	Репозиторий -- это папка, которая отслеживается Git'ом. Признаком этого является
	  наличие в ней подпапки .git
	Всякий репозиторий является директорией, но не всякая директория -- репозиторий.
    Working tree (рабочая директория) -- это репозиторий за вычетом папки .git,
      т.е. те самые файлы и папки, за которыми следит Гит.

Способ первый.
  Мы должны текущим рабочим каталогом командной строки сделать папку с проектом. 
  ВНИМАНИЕ! Саму папку, а не каталог, её содержащий (что относится скорее ко второму способу)
  Затем надо ввести команду git init
  Она превратит текущую папку в репозиторий Git'а, создав при этом подпапку .git
  Всё, можно работать с гитом прям из этой директории 
    (т.е. не надо делать cd, в отличие от второго способа)

Способ второй.
  Мы должны текущим рабочим каталогом командной строки сделать папку, которая будет 
    содержать будущий репозиторий
  ВНИМАНИЕ! В отличие от первого способа, здесь мы как бы отправляемся уровнем выше,
    в наддиректорию. Ну хотя бы по той причине, что пока ещё нет директории репозитория.
    Самостоятельно создавать новую директорию тоже не надо, она будет создана автоматически.
    Просто надо быть на уровень выше.
  Далее пишем следующую команду:
    git clone <url>
	где <url> -- это адрес удалённого репозитория. В ГитХабе его можно найти следующим образом:
	зайти на страничку репозитория и вверху справа найти зелёную кнопку с надписью "<> Code". 
	Там на вкладке Local на подвкладке HTPPS будет текстовое поле с адресом, который нужно 
 	скопировать (есть даже специальная кнопка) -- это и будет нужным нам url'ом. 		
  Команда git clone создаст новую директорию с именем удалённого репозитория и скопирует в неё всё
    его содержимое (вместе с папкой .git, разумеется)
  Далее нужно будет перевести текущий рабочий каталог командной строки в эту директорию (с помощью
    комнады cd, например)
  Всё, можно работать.
  ПРИМЕЧАНИЯ:
    1) По умолчанию в процессе клонирования удалённому репозиторию присваивается имя origin
       Однако при клонировании можно задать другое имя, для этого следует использовать:
       git clone -o <newname> <url>
    2) Также по умолчанию репозиторий клонируется в папку, называющуюся так же, как удалённый
       репозиторий. Но можно имя папки поменять (например, чтобы создать копию репозитория для
       работы с двумя ветками параллельно). Для этого годится следующая команда:
         git clone <url> <имя_папки>

Лёша учил меня второму способу.
Говорил, что в первом способе ещё придётся потом настраивать origin (=удалённый репозиторий),
  что пока что я плохо представляю, как делать
  (хотя на данный момент у меня до сих пор возникают проблемы с этим origin и после второго 
  способа... м-да)


Как "разгититься"? Удалить папку ".git"

Как понять, в репозитории мы находимся или в папке?
Самый простой способ это сделать — набрать в терминале команду «git status». Если в ответ вы увидите 
ошибку «fatal: not a git repository (or any of the parent directories): .git», значит, в терминале
вы вызываете команду не из репозитория, а из обычной папки. Если вы увидели что-то другое, 
то вы находитесь в репозитории или внутри одной из папок, которая находится в нём (в частности, если
вы вызовите git status из папки .git, то получите следующее сообщение: «fatal: this operation must 
be run in a work tree»; вызов же из "нормальных" папок будет более привычным и адекватным).


Хорошая статья по этой теме: https://habr.com/ru/articles/718830/




 = = = Индексация = = =

index (=staging area =cache) — область зафиксированных изменений, т.е. всё то, 
	что вы подготовили к сохранению в репозиторий.

git add <file>...	Заиндексировать файл(ы)
git add	.			Заиндексировать всю текущую папку
git add -A			Заиндексировать все изменения
git add --all		То же, что -A
git add -f <file>	Добавить файл принудительно (даже если он есть в .gitignore)
	
	Замечание насчёт "git add .":
	Если текущая папка -- корневая папка репозитория, то "git add ." == "git add -A"
	Но если в репозитории есть поддиректории и если перейти в одну из них, 
		то вызов "git add ." заиндексирует только её содержимое
	
	Замечание насчёт пустых папок.
	Гит не видит пустые папки... по историческим причинам :)

	Замечание насчёт удаляемых файлов:
	Если мы удалили файлы из репозитория, то чтобы Гит тоже считал их удалёнными, нужно
	  закоммитить их удаление, а прежде -- заиндексировать! Иначе Гит не запишет удаление 
	  в свою историю и будет в git status отображать такие файлы в списке Changes not 
	  staged for commit красным цветом с пометой deleted.
	Удалившиеся файлы можно индексировать как с помощью "git add <file>", так и 
	  с помощью "git add .". Также они автоматически будут добавляться в коммит при 
	  выполнении команды git commit -a
	При этом с точки зрения операционной системы такие файлы уже, естественно,
	  не существуют, поэтому ввести их имена в командной строке с помощью Tab-подсказки 
	  не выйдет, однако ручной корректный ввод несуществующего файла будет корректно 
	  обработан, т.к. Git-то его помнит!
			
	git rm <file>...				Удалит файл и сведения об удалении положит в индекс
										(с флагом -r можно и для папок)
	git mv <old> <new>				Переименует/переместит файл и сообщит об этом в индекс

Как разиндексировать файл(ы)? См. далее главу "Отмена действий"
(Также там написаны ещё некоторые возможности команды git rm)

Добавление в индекс файла, в котором нет изменений, ни к чему не приведёт


     = = = Индексация файла по частям: git add -p = = =
  
    git add -p или git add --patch
    Открывает интерактивный интерфейс. 
    Проходит по диффу файла между текущей и последней заиндексированной/закоммиченной
      версией, отделяет друг от друга куски, между которыми как минимум 7 неизменных
      строк, спрашивает по каждому куску:
  	y - индексировать этот кусок
  	n - не индексировать этот кусок
  	q - выйти (в индексе останется всё, что успели внести в индекс)
  	a - индексировать этот кусок и все последующие куски в файле
  	d - не индексировать этот кусок и все последующие куски в файле
  	? - вывести справку
  	s - разделить этот кусок ещё сильнее:  не через 7 неизменных строк, а через 1
  	e - внести изменения в текущем куске вручную (откроется сторонний редактор)
		  Комментарий по поводу последнего пункта "e":	
			Сделанные в редакторе изменения попадут только в индекс, но не в текущую версию.
			  (туда они попадут только через git restore <file> или через коммит и хардресет, см.ниже)
			Таким образом, в индексе может оказаться информация, которой нет ни в текущей версии, 
			  ни в последней закоммиченной.
			Команда полезна, если Git разметил дифф не так, как нам хотелось бы, но при её использовании
			  нужно быть аккуратным и понимать, что есть какие-то отличия, которых нет в текущей версии файла.
			Ещё момент: если мы, скажем, в git add -p исправляем последнее отличие текущей версии от индекса
			  и вызываем эту команду "e", затем пишем что-то в редакторе, то в итоге файл не пропадёт из
			  красного списка в git status (как было бы, если б мы просто добавили данное отличие в индекс).
			  Однако теперь в зелёном списке (т.е. в индексе) будет более свежая версия, чем в красном
			  (где текущая), хотя в "обычном" сценарии наоборот: в красном списке версия свежее и нужно
			  обновлять индекс через add. Здесь же можно:
			   1) текущую версию файла подобновить из индекса: git restore <file>
			   2) забить на красный список, делать коммит, а потом делать хардресет, чтобы
					убрать старую текущую версию и влить в неё изменения, сделанные через "e"
					(хотя вместо хардресета опять-таки сгодится git restore <file>)
			Однако если это было не последнее отличие в диффе, а впереди у нас ещё много изменений
			  нашего файла, которые нужно коммитить по отдельности, то добавленные через "e" правки
			  в текущей версии просто так не увидишь, их нужно держать в голове либо:
			    - делать git stash push (а после просмотра -- git stash pop) -- покажет нам коммит;
			      - если не делал коммит, то просмотреть индекс можно после git stash push -k;
			    - смотреть в сторонних программах содержание индекса или коммита;
			    - делать git push и смотреть в remote.
			

    Хорошая статья по теме: https://nuancesprog.ru/p/7502/ 


	 = = = Индекс во время конфликтов, слоты (стадии) индекса = = =
	 
	Когда происходят какие-либо конфликты, индекс начинает вести себя необычно :)
	В нём появляется особый красный список both modified, в который попадают конфликтные файлы.
	Но это ещё не всё...
	
	У индекса вообще говоря для любого файлы используется 4 слота (стадии): от 0 до 3.
	В обычной ситуации файлы попадают только в нулевой слот, а слоты с 1 по 3 пусты.
	Но в случае конфликта наоборот: слот 0 пуст, а слоты с 1 по 3:
		1 слот -- версия файла из общего предка (base)
		2 слот -- текущая версия файла (ours)
		3 слот -- версия файла из вливаемой ветки/коммита (their)
	Посмотреть содержимое слотов можно по команде git show :<n>:<file>
	Если есть файлы в слотах 1-3, то это значит, что есть конфликты
 		(Вообще говоря, не всегда все слоты 1-3 заполнены; к примеру, если во вливаемой и текущей ветках
 		 будет независимо создан новый файл, которого не будет в base, то слот 1 будет пуст, а слоты 2-3 нет)
	Если сделать git add <файл>, то слоты 1-3 очистятся, а в слот 0 попадёт текущая версия файла
		(вместе с "потрохами" конфликта: "<<<<<<< HEAD" и т.д.).
		Файл в таком случае перестанет быть конфликтным и попадёт в зелёный список modified.
	(Но разумеется правильным будет перед индексацией привести конфликтующий файл в подобающий вид.) 




 = = = Статусы файлов в Гите = = =

untracked	Файл не отслеживается Гитом: ни разу не индексировался (свежедобавленный)
tracked		Файл отслеживается Гитом (тут и закоммиченные, и только проиндексированные)
staged		Файл заиндексирован
modified	Файл отличается от последней закоммиченной версии


	 = = Списки в гитстатусе = = 
	
	Untracked files
		список неотслеживаемых (untracked) файлов, помечается красным
	Changes not staged for commit
		список файлов с непроиндексированными изменениями (modified),
		    помечается словом modified и красным - если файл был изменён
		    помечается словом deleted и красным - если файл был удалён
	Changes to be committed
		список индексированных (staged, modified) файлов, 
		    помечается словом modified и зелёным - если индексировался ранее - ИЛИ
		    помечается словами new file и зелёным - если новый файл
		    помечается словом deleted и красным - если файл был удалён


	Если файл в проекте изменить, то он будет в Changes not staged for commit
	Если его заиндексировать, то он будет в Changes to be committed
	Если его снова изменить, то он будет и там, и там
		(при этом коммит на текущем этапе закоммитит только проиндексированную
		    версию, а git restore откатит тоже к индексированной версии,
		    и в этих обоих случаях из списка Changes to be committed файл пропадёт)
	
	Если все те три списка пусты, то гитстатус выводит вот это:
		On branch krull_fixes
		[Your branch is up to date with 'origin/<...>'.]
		nothing to commit, working tree clean
			(нечего коммитить, рабочая директория чиста)




 = = = Отмена действий = = =

git restore <file>...			Отменить все неиндексированные изменения в файле(-ах)
git restore -W <file>			То же самое
git restore .					Отменить все неиндексированные изменения во всех отслеживаемых файлах 
									в текущей папке	(см. также git reset)

git restore --staged <file>...	Разыиндексировать файл(ы)
git restore -S <file>...		То же самое
git reset <file>...				То же самое
git rm --cashed <file>...		То же самое
git rm -r --cashed <dir>...	  	То же самое (но для папок)

git restore -S .				Разындексировать все файлы из текущей директории
git reset						Разындексировать ВСЕ файлы

Обрати внимание: git restore не меняет индекс, но меняет сам файл в репозитории, а git restore -S наоборот
меняет индекс, но сам файл в репозитории остаётся неизменным.

Если мы что-то поменяли в репозитории, наиндексировали, ещё раз поменяли и т.д., а потом решили откатить
репозиторий к последнему коммиту, то по идее надо сначала всё сперва разыиндексировать, потом 
все неиндексированные (т.е. ещё незаиндексированные и уже разындексированные) изменения отменить.
Логика подсказывает использовать "git restore -S .", затем "git restore .". Их можно объединить:

git restore -SW .		Отментить вообще все изменения в текушей папке, откатить до последнего коммита
						(эта команда не тронет лишь свежедобавленные и потому неотслеживаемые файлы)
					(да, ради этого я выше описал команду git restore -W)
Однако никто так не делает, ибо для этого есть git reset --hard: см. далее


git reset [--soft | --mixed | --hard] [<commit>]	Откат состояния к данному коммиту

git reset может содержать указатель на коммит (в таком случае мы перейдём к тому коммиту),
	а может и не содержать (тогда перейдём к текущему коммиту)
git reset тащит за собой указатель на текущую ветку (!!!)

git reset бывает трёх видов:
  1) --soft:
	Откатывает до коммита, а все изменения между новым и старым коммитами пишет в индекс (т.е. в staged)
	С самим репозиторием ничего не происходит, с изначальным индексом тоже ничего не происходит (разве что
	к нему возможно прибывает пополнение), изначальный список unstaged-изменений тоже остаются как был
  2) --mixed (делается по умолчанию, если не указывается флаг): 
	Откатывает до коммита, а все изменения между новым и старым коммитами пишет в unstaged,
	а всё, что изначально было в индексе, разындексирует -- т.е. тоже в unstaged
	Изначальные unstaged-измнения остаются как были (разве что к ним возможно прибывает пополнение)
	С репозиторием по-прежнему ничего не происходит
  3) --hard:
	Откатывает до коммита, а все изменения нафиг стирает, соответсвенно репозиторий откатывается
	к состоянию на момент того коммита (за исключением лишь недавно добавленных в репозиторий
	неотслеживаемых (untracked) файлов, их хардресет не замечает и потому не трогает; наличие таковых --
	единственное, что отличает состояние репозитория после хардресета от состояния того коммита, на
	который делается хардресет).
	Весь изначальный индекс и все изначальные незакоммиченные изменения нафиг уничтожаются БЕЗВОЗВРАТНО!
		(помимо уже упомянутых untracked-файлов)
	ВНИМАНИЕ! Перед выполнием всегда проверять с помощью git status, есть ли изменения (заиндексированные
	или нет), потому что в результате действия хардресета они пропадут БЕЗВОЗВРАТНО! ну если конечно они
	нам нужны :) А если снести эти изменения наша цель, то таки да, хардресет наше всё :))
	ВНИМАНИЕ! Если делать хардресет на коммит, отличный от текущего, то с текущего коммита уйдёт текущая
	ветка. Если на этот коммит указывала только эта ветка и не указывали никакие другие ветки даже
	опосредованно через иные коммиты, то в результае выполнения git reset --hard этот бывший текущий коммит
	становится висящим (т.е. на него не указывает ни одна ветка), вместе с ним висящими становятся и все
	его предки вплоть невключительно до того коммита, на который хоть какая-то ветвь всё же указывает --
	в результате все эти коммиты пропадут из git log, добраться до них можно будет только через git reflog

Замечания:
  git reset --soft без указания на коммит (или, что тоже самое, с указанием на текущий коммит) не делает ничего
  git reset без указания на коммит аналогичен действию git restore -S . (если мы в корневой папке репозитория),
	т.е. тупо очищает индекс
  git reset --hard без указания на коммит обнуляет все измненения (заиндексированные и нет) в репозитории,
	т.е. действует как git restore -SW . (опять-таки, если мы в корневой папке репозитория); исключение
	составляют лишь свежедобавленные и потому неотслеживаемые файлы
  git reset --hard <commit> похож по действию на git checkout <commit>, вот только первый тащит за собой
	текущую ветку, а второй оставляет её там, где была. Но с репозиторием происходит одно и то же.
	ВНИМАНИЕ! У обоих способов есть проблемки: у чекаута -- оторванная башка, опасная тем, что может
	впоследствии породить висящие пропащие коммиты, хардресет же может сразу один или несколько коммитов
	сделать висящими. Подробнее об этом -- в справке по каждой команде.
  git reset --hard HEAD~ удаляет последний коммит.
  Когда git reset перемещает ветку, то она записывает предыдущее значение HEAD в файл ~/.git/ORIG_HEAD

Хорошая небольшая статья про git reset: https://habr.com/ru/articles/203282/

git checkout <хэш> <file>...		Из указанного коммита достанет версию указанного файла и поместит её 
										в текущий индекс (состояние репозитория не переключит)


	 = = = Как быть с неотслеживаемыми файлами/папками = = =

	Если хочется очистить каталог от всякой незакоммиченной шушеры, то можно делать git reset --hard,
	однако это не повлияет на неотслеживаемые файлы и папки
	
	Чтобы очистить репозиторий от этого мусора, нужно выполнить следующую команду:
		git clean -f
		  доп. флаги:
			-d 	без этого флага удалит только файлы корневой папки, с ним - все файлы и папки
			-x 	с этим флагом почистит даже то, что указано в .gitignore




 = = = Коммитинг = = =

git commit					Закоммитить текущий индекс (откроется сторонний текстовый редактор 
								для написания комментария)
git commit -m <comment>		Закоммитить текущий индекс (комментарий указывается прям здесь в кавычках,
								а если он одним словом без пробелов, то можно и без кавычек)
git commit -a				Закоммитить все изменения в проекте 
							(кроме добавления новых файлов, т.к. они untracked;
							при этом удаления новых файлов будут закоммичены, т.к. они tracked)
git commit -am <comment>	Комбо из предыдущих двух; довольно ходовая команда :)
git commit <file>...		Закоммитить указанный(е) файл(ы) напрямую из репозитория в обход индекса; 
								при этом с индексом и с unstaged ничего не происходит (если не считать
								самого этого файла(ов): он(и) убирается и из индекса, и из unstaged).
								Можно также добавить -m с комментом (перед файлом(ами))
								Внимание: не работает для новых неотслеживаемых файлов!

  ЗАМЕЧАНИЯ:
  1. Если индекс пуст, то команды <git commit>, <git commit -m "smthng"> работают так же, как <git status>.
     Команда <git commit -a> в случае пустого индекса, но непустого списка изменений работает как полагается 
       (всё индексирует + всё коммитит), но в случае пустого списка изменений всё-таки работает как <git status>
       (ну то есть выдаёт слова "On branch <ветка> // nothing to commit, working tree clean") 
  2. Если делать коммит через сторонний редактор, есть возможность отменить процесс коммитинга.
     Просто нужно написать пустое сообщение в коммит -- всё, операция отменится.
  3. Хорошим тоном является добавление в коммент коммита номера выполняемой задачи.
     Если работать с GitHub'ом, то там задачу нужно указывать в виде #<номер задачи>
     Если ставить это дело в самое начало коммента, то при работе в стороннем редакторе символ # воспримется
       как служебный: в самом деле, в редакторе полно строк, начинающихся с #, по всей видимости они 
       воспринимаются как игнорируемые; в таком случае и написанный нами коммент будет проигнорируем,
       Гит сочтёт коммент пустым и согласно предыдущему замечанию коммитинг тупо отменится
     Но всё-таки можно начать коммент с #: надо просто перед ним поставить дополнительный пробел, который,
       к слову, в коммент как ни странно не попадёт и сам коммент начнётся с #, чтд.
  4. Если хотим написать сообщение в коммит на нескольких строках, то нужно вторую строку сделать пустой.
	 Таким образом первая строка будет проинтерпретирована как заголовок коммита, а третья и последующие --
	   как обычный текст. (Но как правило обходимся одной строкой, конечно же)

git commit --amend				Исправить последний коммит
								(работает только для последнего, остальные уже не исправить)
								Также можно добавить флаги -a, -m  или -am (см. выше)
git commit --amend --no-edit	Исправить последний коммит, но не трогать при этом коммент

	ВНИМАНИЕ! Если исправлять уже запушенный коммит, то потом пуш просто так не получится, 
	  но можно сделать форспуш (подробнее см. Пушинг)


git checkout <commit>	Перевод состояния репозитория (т.е. указателя HEAD) к данному коммиту 
							(указывается его хэш или любой иной указатель на этот коммит, если есть)
							Работает, если репозиторий не менялся с момента последнего коммитинга
	ВНИМАНИЕ!
	Если мы хотим переключиться на какую-то ветку, то должны указывать эту ветку. Если же вместо неё указать
	коммит, на который она указывает, то мы переключимся на сам коммит, а HEAD будет указывать на него, а не 
	на ветку. Таким образом в логе будет написано не "HEAD -> branchname", а "HEAD, branchname".
	Получается, что HEAD указывает напрямую на коммит. Такая ситуация называется detached HEAD 
	(отсоединённый или оторванный HEAD), команда git status выдаёт "HEAD detached at <commit hash>",
	причём красным цветом. То же состояние detached HEAD получится и в случае, если мы просто
	переместимся на какой-то коммит, на который не указывает какая-либо ветка.
	По-хорошему репозиторий не должен долго находиться в таком состоянии. Тут вижу
	два варианта действий:
	  1) Если мы просто зашли посмотреть на коммит: посмотрели и возвращаемся обратно на ту ветку, где были
	  2) Если мы захотели отпочковаться от данного коммита: первым делом следует создать здесь 
		новую ветку, затем не забыть(!) на неё переключиться (или одним выстрелом двух зайцев с помощью
		git checkout -b) -- тем самым мы выйдем из состояния оторванной башки; 
		далее можно коммитить в эту ветку сколько угодно
	Во время состояния оторванной головы Git Bash в конце строки состояния вместо имени ветки в скобках
	  пишет хэш текущего коммита, но уже в двойных скобках!
	Хорошая статья по теме: https://webhamster.ru/mytetrashare/index/mtb0/1465119902140pozfhh1
	(в т.ч. см. там причину, почему оторванный HEAD -- зло)

	Замечание.
	git checkout HEAD@{0} отсоединит HEAD от текущей ветки и направит его напрямую на коммит. Будет
	  состояние detached HEAD. Однако git checkout HEAD или git checkout @ не сделает ничего -- это 
	  весьма странно, учитывая, что git rev-parse на HEAD, @ и HEAD@{0} выдаёт одинаковые хэши...
	  Может дело в том, что на @ стоит ветка? но если на @~1 стоит какая-то ветка, то git checkout @~1
	  всё равно отрывает башку... странно короче.


git revert <commit hash>	Отмена изменений коммита -- не такая простая штука, как кажется на перввый взгляд
					см. чуть ниже!!!
				При этом создаётся новый коммит, который добавляется в конец дерева коммитов
					(т.е. после текущего HEAD, ну и HEAD туда перемещается, всё норм тут)
				И открывается сторонний редактор для редактирования коммента, там по умолчанию:
					Revert "<коммент того коммита>"
				Кстати, если сделать реверт на реверт, то коммент будет: 
					Reapply "<коммент того коммита>"
	КАК В ДЕЙСТВИТЕЛЬНОСТИ РАБОТАЕТ git revert:
	  Каждый коммит в некотором смысле является набором изменений по сравнению в предыдущей версией.
	  И git revert инвертирует именно сами изменения между соседними коммитами, а не откатывает к какой-то
	  старой версии. Именно что запросто может создасться версия репозитория, которой ещё не было!
	  Конечно, если мы ревёртим последний коммит, то у нас создаётся новый коммит с таким же состоянием 
	  репозитория, как у предпоследнего коммита (точнее уже предпредпоследнего). Но если мы ревёртим
	  не последний коммит, то инвертирование какого-нибудь позапозапрошлого набора изменений, вообще говоря,
	  запросто может привести к конфликту изменений. Этот конфликт изменений может быть разрешён
	  в автоматическом режиме, а может и нет -- придётся использовать git mergetool (см. Мёржинг)
git revert <commit hash> --no-commit
						Сделает ревёрт, то остановится перед стадией создания коммита,
							даст шанс переделать коммит и/или его сообщение
git revert <commit hash> -n
						То же самое

git revert --abort		Отменяет выполнение revert и возвращает к состоянию до её вызова
				(например, если возник конфликт слияния и хочется просто всё вернуть как было)
git revert --continue	Продолжает выполнение процесса


git cherry-pick <commit_hash>	берёт изменения, которые были сделаны в указанном коммите, 
	и накладывает на текущую ветку. Можно сказать это как git revert, только наоборот
	(наверное есть некоторые отличия, но пока не хочу в них вдаваться)
	Эта команда копирует имя и дату автора коммита (но не копирует имя и дату коммиттера)
	Флаг -x добавляет в описание информацию о том, откуда коммит был скопирован
git cherry-pick --no-commit <commit_hash>
							Сделает черри-пик, но остановится перед стадией создания коммита,
								даст шанс переделать коммит и/или его сообщение
git cherry-pick -n <commit_hash>
							То же самое
git cherry-pick --abort		Отменяет выполнение cherry-pick и возвращает к состоянию до её вызова
				(например, если возник конфликт слияния и хочется просто всё вернуть как было)
git cherry-pick --continue	Продолжает выполнение процесса

Как удалить последний коммит? 
git reset --hard HEAD~
(Разумеется, перед хардресетом надо проверить, нет ли незакоммиченных изменений, которые не хочется терять)




 = = = Всякие названия, сокращения = = = 

origin			Имя удалённого репозитория, с которого сделал clone.
					Это имя "origin" даётся автоматически по умолчанию, однако вместо него
					можно задать другое имя, если вместо git clone <url> написать 
					git clone -o <newname> <url> при изначальном клонировании репозитория.
main			Главная ветка (бывает, называют master, но это неполиткорректно; ещё: trunk)
					Если по отношению к коммиту - то означает, что это крайний коммит ветки
<hash>~<n>		n-й предок коммита (по главной линии: каждый родитель -- первый, если их несколько)
<hash>~			То же, что и <hash>~1
<hash>^<n>		n-й родитель коммита (относится к мёрж-коммитам, у которых несколько родителей)
<hash>^			первый родитель коммита -- то же самое, что и <hash>~
HEAD			Текущее состояние репозитория, указатель на текущий коммит
@				То же самое (но вроде не любая ОС интерпретирует этот символ верно)
HEAD~<n>		n-й предок HEAD'а
HEAD~			То же, что и HEAD~1

HEAD@{<n>}			Указывает на хэши коммитов по списку в reflog, т.е. это коммит, куда HEAD
						указывал n шагов назад по истории переключений HEAD'а (т.е. по reflog'у)
<branch>@{<n>}		То же самое, но по рефлогу для ветки <branch>
@{<n>}				То же самое, но по рефлогу для текущей ветки

origin/<branchname> -- это т.н. ветки слежения. Ветка слежения — это ссылка на определённое 
  состояние удалённой ветки. Это локальные ветки, которые нельзя перемещать; Git перемещает 
  их автоматически при любой коммуникации с удалённым репозиторием, чтобы гарантировать 
  точное соответствие с ним. См.: https://git-scm.com/book/ru/v2/Ветвление-в-Git-Удалённые-ветки
origin/main			Главная ветка на удалённом репозитории
origin/HEAD			Указывает, что на удалённом репозитории данный коммит текущий




 = = = Работа с ветками = = =
 
git branch				Показывает список локальных веток (текущая - зелёная и с *)
  флаги: -r				Показывает список веток с сервака (GitHub etc)
		 -a				Показывает вместе и локальные ветки, и ветки с сервака
		 -v				Показывает вместе с ветками и информацию о коммитах, на которые они указывают
		 -vv			Показывает список связей локальных веток с upstream-ветками
		 --merged		Показывает все ветки, которые когда-либо были смёржены с текущей
		 --no-merged	Показывает все ветки, которые никогда не были смёржены с текущей

git branch <имя_ветки>  Создать новую ветку <имя_ветки>, указывающую на текущий коммит
							Название ветки в Git может состоять из букв, цифр, а также включать
							любой из четырёх символов: ., -, _, /. Эти символы не несут особого смысла. 
git branch <имя_ветки> <хэш_коммита>
						Создать новую ветку <имя_ветки>, указывающую на коммит <хэш_коммита>

git switch <ветка>		Переключиться на ветку (более новая и более уместная команда, 
						  появилась в Гит2.0)
git checkout <ветка>	Переключиться на ветку (более старая команда и используется для других целей,
						  но здесь тоже полностью годится)
git switch -			Переключиться на предыдущую ветку
git checkout -			То же самое

	Переключение веток работает, если пусты modified и staged. Если не пусты, то выдаст ошибку. 
	Если нужно всё-таки переключиться и похерить изменения, можно использовать ключ -f
	ВНИМАНИЕ! Есть ситуации, где переключение веток происходит несмотря на изменения в репозитории! 
	  Так будет, если изменения относятся только к тем файлам, которые не отличаются в исходной 
	  и новой ветках. В таком случае эти изменения переходят на новую ветку! 
	  Гит об этом сообщает, по каждому файлу с изменениями пишет по одной строке вида:
	  M		<filename>

git switch -c <имя_ветки> [<хэш_коммита>] 			Создать новую ветку и сразу же перeключиться на неё
git checkout -b <имя_ветки>	[<хэш_коммита>]			то же самое

git branch -m [новое_имя_ветки]						Переименовать текущую ветку
git branch -m [старое_имя_ветки] [новое_имя_ветки] 	Переименовать любую ветку
	ВНИМАНИЕ! Если переименовывать свежесозданную ветку до первого её пушинга, то всё норм,
	но если переименовывать ветку, которая уже на серваке есть, то есть нюансы
	Подробнее об этих нюансах можно почитать здесь:
		https://git-scm.com/book/ru/v2/Ветвление-в-Git-Управление-ветками

git reset --hard <хэш_коммита>			Переставить указатель текущей ветки на коммит
  (Разумеется, перед хардресетом надо проверить, нет ли незакоммиченных изменений, которые не хочется терять)
git branch -f <ветка> <хэш_коммита>		Переставить указатель НЕ текущей ветки на коммит (либо создать ветку,
											если не создана); с текущей не сработает, выдаст ошибку
git switch -C <ветка> <хэш_коммита>		Переставить указатель любой (и текущей, и не текущей) ветки на коммит
											(либо создать эту ветку, если не создана) и перейти на неё
git checkout -B <ветка> <хэш_коммита>	То же самое

git branch -d <ветка>		Удалить ветку. Работает только если есть какая-то другая ветка, которая
								указывает на тот же коммит, что и данная ветка (т.е. чтобы в результате
								удаления не появились висящие недостижимые коммиты), при этом та другая 
								ветка должна локальной, origin-ветки не сканают. Также не работает, если
								удаляемая ветка -- текущая. 
git branch -D <ветка> = git branch -d -f <ветка>	Принудительно удалить ветку, т.е. несмотря на сказанное
													выше (однако текущую ветку всё равно не удалит)
	Удаление ветки из локального репозитория не удаляет её из origin!
	Локальная ветка и ветка с origin удаляются независимо по отдельности!
	Для удаления с origin есть следующие команды:
		git push -d origin <имя_ветки>
		git push origin :<имя_ветки>
	(после такого из GitHub ветка пропадает, а если найти на неё ссылку где-нибудь в каком-нибудь 
	  пулл-реквесте, то будет ошибка 404)




 = = = Пушинг = = =

git push	Заливает (пушит) текущую ветку на гитхаб, если она там уже есть и корректно настроена
				связь между ней и соответсвующей ей удалённой веткой

			Если нету и/или не настроена связь, то нужно выполнить следующую команду:
git push --set-upstream origin <имя_ветки>
			Пушит новую ветку на гитхаб (и создаёт, и обновляет до последнего состояния, и 
			  связывает локальную ветку с удалённой)
git push -u origin <имя_ветки>			То же самое
git push -d origin <имя_ветки>			Удаляет ветку из origin
git push origin :<имя_ветки>			То же самое  (пробел перед : важен!)	

git push --all	  Пушит все ветки разом
			(Причём каким-то образом пушит даже те ветки, у которых связь не настроена...
			Не совсем понимаю, почему так происходит, ну и ладно: надо просто всегда
			ветки нормально связывать, вот и всё)
git push -u origin --all
				  Пушит все ветки разом и сразу им ещё и связь настраивает
	ВНИМАНИЕ! Не стоит повсеместно прибегать к этим двум командам, т.к. на локалке могут заваляться
	  всякие старые ненужные ветки, лить их на сервак ни к чему, ибо они там -- мусор, который ещё 
	  удалять придётся. Лучше пушить по одной ветке.

git push --force				Форспушинг (см. далее)
git push -f						То же самое
git push --force-with-lease		"Мягкий" форспушинг (см. далее)

	 = = = Форспушинг и "мягкий" форспушинг = = =
	Если поправить какие-нибудь старые коммиты в истории git, например: исправить имя автора или e-mail, 
	или отменить последний коммит или воспользоваться amend или revert, то git не даст сделать push
	В таком случае надо делать форспуш
	Но в этом случае мы рискуем перетереть чьи-нибудь изменения, если с тех пор, как мы забирали изменения 
	с сервера, кто-то успел запушить свои коммиты. Поэтому лучше использовать более безопасную команду
	git push --force-with-lease 
	Такой вариант лучше тем, что если кто-то успел запушить свои коммиты после того, как мы забирали 
	изменения с сервера, то он не будет их перетирать, а выдаст нам ошибку, после чего мы сможем 
	интегрировать чужие коммиты со своими изменениями и попытаться сделать push --force-with-lease ещё раз.
	Взято с: https://urvanov.ru/2017/09/19/опасность-git-push-force-и-полезность-git-push-force-with-lease/




 = = = Защита от Гита: .gitignore = = =

Можно создать файл в папке проекта с именем ".gitignore", где можно перечислить всё, что не должно отслеживаться 
Гитом. Например, туда стоит отправлять пучармовскую папку ".idea" с пучармовскими настройками проекта, т.к. 
другой человек возможно будет работать в другой IDE, у него там свои сопроводительные файлы, пучармовские ему 
ни к чему (свои аналогичные такие файлы ему тоже следует добавить в .gitignore).

	В Проводнике нельзя так просто переименовать файл в .gitignore
	Будет ругаться: следует ввести имя файла
	Как обойти: надо дописать точку в конце имени, после нажатия Enter точка уберётся автоматически.
	Зачем так и почему? Хз, но лайфхак работает и всё тут.

Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или 
в коммит, то правила на него не распространяются.

	Если хочется применить .gitignore к отслеживаемым файлам, надо сделать их неотслеживаемыми.
	Вот тут есть инструкция: https://habr.com/ru/articles/709246/
	Но она чё-то как-то сложна
	Я б сделал как: временно убрал бы эти файлы из репы, закоммитил, затем вернул бы их обратно, 
		не забывв указать их в .gitignore -- вуаля!

Файл .gitignore тоже попадает во все гитовые истории (индексы, коммиты и т.д.), однако для его работы
(по игнорированию файлов/папок) не обязательно делать коммит или даже индекс, достаточно просто сохранить.

Посмотреть список игнорируемых файлов можно с помощью команды git status --ignored

ВАЖНОЕ ЗАМЕЧАНИЕ
Вообще говоря файлу .gitignore в проекте делать нечего, а можно сделать глобальный .gitignore
(и добавить туда, например, папку .idea). Прописать глобальный гитигнор можно в конфиге:
	git config --global core.excludesFile <путь>


	 = = = Шаблоны поиска и символы-джокеры в .gitignore = = =

	Если строка начинается с #, то это комментарий, и .gitignore не будет его учитывать.

	Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне 
	в .gitignore, значит файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.
			# игнорировать все файлы, которые заканчиваются на .jpeg
			*.jpeg
			# игнорировать все файлы "tmp" во всех подпапках папки docs
			docs/*/tmp 
	  Если задать правило, которое состоит только из звёздочки, Git будет игнорировать все файлы. Это происходит 
	  потому, что под звёздочку подходит любое имя файла.
	  Есть небольшое исключение касательно подпапок: звёздочка может указывать лишь на одну подпапку, т.е. если
	    задано правило docs/*/tmp, то папки вида docs/papka/tmp Гит проигнорируют, а вида docs/pap/ka/tmp нет.
	  Если хочется задать произвольное количество подпапок, то нужно использовать символ **. В таком случае при
	    записи в .gitignore строки docs/*/tmp Гит проигнорирует и папки вида docs/pap/ka/tmp тоже.
	  Тем не менее одинарная звёздочка * в .gitignore заставит Гит проигнорировать все файлы, все папки и все 
	    подпапки, т.е. только файлы в корневой папке задать звёздочкой не получится (а жаль). Просто двойные 
	    звёздочки ** работают так же, как и просто одинарная *.

	Вопросительный знак ? соответствует одному любому символу.

	Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, 
	  а только из списка, который указан в скобках.
			# игнорировать файлы file0.txt, file1.txt и file2.txt
			# при этом не игнорировать file3.txt, file4.txt, ...
			file[0-2].txt 
	В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z]).

	Если шаблон в .gitignore начинается со слеша /, то Git проигнорирует файлы или каталоги только в корневой
	  директории. А если без /, то игнорируемые файлы смотрятся не только в корневой папке, но и в подпапках.
			# игнорировать todo.txt в корне репозитория
			/todo.txt
			# для сравнения: spam.txt будет игнорироваться во всех папках
			spam.txt
	То есть по уму чтобы игнорировать файл/папку в корневой папке, надо перед именем ставить /.
	(Правда, шаблон /* по-прежнему проигнорирует все файлы во всех подпапках.)
	Если шаблон заканчивается слешем, то правило применится только к папке.
			# игнорировать папку build
			build/ 
	Обратите внимание: если build — это папка, то она будет проигнорирована. Если build — обычный файл, 
	  то он не подпадёт под правило и не будет игнорироваться.

	Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).
			# игнорировать все JPEG-файлы
			*.jpeg
			# но только не мем с Doge
			!doge.jpeg 




 = = = Мёржинг = = =

(не доизучено, доизучать!)

git merge 	ИЗУЧИТЬ!!
git merge --abort	Отменяет выполнение merge и возвращает к состоянию до её вызова
			(например, если возник конфликт слияния и хочется просто всё вернуть как было)

git mergetool		Вызывает сторонную программу разрешения конфликтов
			Вызывается та программа, которая в .gitconfig записана в merge.tool (см. ниже)
git mergetool --tool=<имя_программы>
			Вызывает стороннюю программу <имя_программы> для разрешения конфликта 

	 = = = О настройке mergetool = = =

	Чтобы работать со сторонней мёржтулой (mergetool), нужно её сперва установить, а затем настроить
	Настроить нужно две вещи: во-первых саму мёржтулу, во-вторых мёржтулу по умолчанию.
	Обе настройки прописаны в .gitconfig
		Этот файл в зависимости от ОС может находится в разных местах, у меня сейчас он находится
		непосредственно в папке C:\Users\<user>
	Чтобы выполнить каждую из этих настроек, можно вбить специальную команду, начинающуяся с:
	git config --global
	или можно вручную отредактировать файл .gitconfig
	
	1) Настройка самой мёржтулы
	   Нужно вбить команду
	   git config --global mergetool.<имя_мёржтулы>.path "<адрес_мёржтулы>"
	   В файле .gitconfig должно появиться следующее:
		[mergetool "<имя_мёржтулы>"]
			path = <адрес_мёржтулы>
	   (да, с кавычками здесь всё так)
	
	2) Настройка мёржтулы по умолчанию
	   Нужно вбить команду
	   git config --global merge.tool=<имя_мёржтулы>
	   В файле .gitconfig в секции [merge] поле tool должно принять значение <имя_мёржтулы>
	   т.е. должны быть две следующие строки:
		[merge]
			tool = <имя_мёржтулы>

	Примечание насчёт синтаксиса файла .gitconfig
	Сравни, в каком виде попадают в .gitcongig двухуровневые и трёхуровневые конструкции,
	  особенно что происходит со средним полем в трёхуровневой конструкции, весьма забавно :)

	Просмотреть список доступных мёржтул можно по команде:
	git mergetool --tool-help
	(правда, почему-то у меня не отображаются установленные мной мёржтулы... возможно, я не 
	 совсем верно сделал записи в .gitconfig... ну и хрен с ним, главное всё работает)


	 = = = О функционале мёржтул = = =

	В процессе разрешения конфликта создаётся 4 файла с разными пометками:
	BACKUP -- видимо, просто копия изначального файла
	BASE -- общий предок обеих версий
	LOCAL -- версия, в которую подмешивают
	REMOTE -- версия, которая подмешивается

	В мёржтулах бывает 2 или 3 исходных окна (это локал с ремоутом, опционально бейз) плюс
	  окно с итоговым результатом
	В мёржтулах по сути нужно только выбирать варианты, иногда какой-то свой код писать.
	По сути больше ничего и не надо.

	ВНИМАНИЕ!
	После завершения работы мёржтулы Гит почему-то оставляет файл с названием
	<имя_бывшего_конфликтящего_файла> + ".orig"
	в котором (вроде как) сохраняется изначальный "гибридный" конфликтный файл 
	(т.е. со всякими этими служебными строками типа <<<<<<< HEAD ).
	После удачного разрешения конфликта НУЖНО ОБЯЗАТЕЛЬНО УДАЛИТЬ ЭТОТ ФАЙЛ!!!	




 = = = Пуллинг = = =

(не доизучено, доизучать!)

git fetch	 привносит актуальность локальному репозиторию без 
			изменения его дерева или текущей ветки
git pull	связка последующих команд git fetch и git merge




 = = = Ребейзинг = = =

git rebase -i				Откроет файл, управляющий ребейзом (?)
git rebase --interactive 	То же самое

Раздел не дописан

Пара комментов с Хабра: https://habr.com/ru/articles/201922/
Главное в туториалах по rebase — не делайте этого с комитами, доступными не только вам.
То же касается и amend и вообще любых правок репозитория после того как сделан git push. 
 Кстати, об этом неплохо-бы написать в статье, пусть даже многие сервера и не принимают такие правки.
А ещё не делать git pull --rebase или git rebase после мержа веток.




 = = = Сравнение версий = = =

git diff		Показывает отличия текущей версим репозитория от последней заиндексированной или
				от последнего коммита, если индекс пуст
git diff --staged	Не совсем понял, надо будет уточнить получше, чё там с индексом xDDD




 = = = Информационные команды: = = =

git --version		Проверить текущую версию Git'а
git remote -v		Проверить текущие url'ы репозиториев
git status		Проверка текущего статуса: 
				в какой ветке сейчас локальный репозиторий
				какие файлы (не) заиндексированы (=(не) подготовлены к коммиту)
				какие файлы (не) закоммичены
git log			Показывает все коммиты текущей ветки
 ключи:	--all		Показывает все коммиты вообще
	--graph		Не просто перечисляет коммиты, но отрисовывает вложенную структуру
	--oneline	Кратко по каждому коммиту, только в одну строку (кусок хэша и коммент)
		(имеет смысл сразу все 3 штуки делать)
git log -<N>	Показать последние N коммитов текущей ветки
git blame <file>	Просмотреть, кто, что и когда изменил в <file>
				(инфа по каждой строке файла)
git reflog		Показать журнал изменений в заголовке локального репозитория. 
			Отличный вариант для поиска утраченных данных.

gitk			Запуск гуя. Покажет текущую ветку (вроде как, но это не точно)
gitk --all		Гуй покажет все ветки, построит строковое графическое дерево

git help		Подсказка гита
git <команда> --help	Открывает в браузере интернет-страничку с подробнейшей информацией по
				данной команде




 = = = Если вывод не помещается на страницу (например, от git log): = = =

Git хочет показать вам более одного экрана с информацией, для этого он вызывает стандартную
программу пейджера Unix less. Просто введите q, чтобы вернуться в терминал, когда вы больше не
хотите перемещаться по выходным данным.

q вернуться в терминал
j перейти на одну строку вниз
k переместиться на одну строку вверх
space перейти на одну страницу вниз
b перейти на одну страницу вверх
h показать помощь
/ поиск вперёд
? поиск назад

Внимание! Должна быть включена английская раскладка, с русской не работает!